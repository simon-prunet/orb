

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Code documentation: utils modules &mdash; orb  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Code documentation: core modules" href="code.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> orb
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="code.html">Code documentation: core modules</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Code documentation: utils modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.astrometry">orb.utils.astrometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.err">orb.utils.err module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.fft">orb.utils.fft module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.filters">orb.utils.filters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.fit">orb.utils.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.image">orb.utils.image module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.io">orb.utils.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.log">orb.utils.log module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.misc">orb.utils.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.parallel">orb.utils.parallel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.photometry">orb.utils.photometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.sim">orb.utils.sim module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.spectrum">orb.utils.spectrum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.stats">orb.utils.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.validate">orb.utils.validate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.vector">orb.utils.vector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.web">orb.utils.web module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">orb</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Code documentation: utils modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/code_utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="code-documentation-utils-modules">
<h1>Code documentation: utils modules<a class="headerlink" href="#code-documentation-utils-modules" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-orb.utils.astrometry">
<span id="orb-utils-astrometry-module"></span><h2>orb.utils.astrometry module<a class="headerlink" href="#module-orb.utils.astrometry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="orb.utils.astrometry.Gaussian">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the gaussian profile</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Gaussian profile used here is:
<span class="math">f(x,y) = H + A \times \exp(\frac{-r^2}{2 W^2})</span></p>
<p>and,
<span class="math">r = (x - dx)^2 + (y - dy)^2</span></p>
<p class="last">The total flux F under the 2D profile is:
<span class="math">F = 2 \pi A W^2</span></p>
</div>
<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
<p>The total flux F under a 2D profile is :
<span class="math">F = 2 \pi A W^2</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Under a 1d profile the flux is <span class="math">F = \sqrt{2\pi}A W</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>amplitude_err</strong> – estimation of the amplitude error</li>
<li><strong>width_err</strong> – estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm']</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.width">
<code class="descname">width</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.Moffat">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Moffat</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the Moffat profile.</p>
<p>This profile is useful to fit stars on CCD arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Moffat profile has been first proposed by Moffat
(1969) A&amp;A. The exact form of the equation used has been derived
from Trujillo et al. (2001) MNRAS, 977. The PSF:</p>
<p><span class="math">f(x,y) = H + A \times [1+(\frac{r}{\alpha})^2]^{-\beta}</span></p>
<p>with,
<span class="math">\alpha = \frac{\text{FWHM}}{2\sqrt{2^{1/\beta} - 1}}</span></p>
<p>and,
<span class="math">r = (x - dx)^2 + (y - dy)^2</span></p>
<p class="last">The total flux F under the 2D profile is thus:
<span class="math">F = A \times \frac{\pi \alpha^2}{\beta - 1}</span></p>
</div>
<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.alpha">
<code class="descname">alpha</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>amplitude_err</strong> – estimation of the amplitude error</li>
<li><strong>width_err</strong> – estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Not implemented yet!</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm', 'beta']</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.PSF">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">PSF</code><a class="headerlink" href="#orb.utils.astrometry.PSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>General class of inheritance for point spread functions (PSFs)</p>
<dl class="method">
<dt id="orb.utils.astrometry.PSF.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.PSF.params">
<code class="descname">params</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.PSF.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.PSF.varray2d">
<code class="descname">varray2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.varray2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vectorized 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Length of the returned array along x axis</li>
<li><strong>ny</strong> – Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">aperture_photometry</code><span class="sig-paren">(</span><em>star_box</em>, <em>fwhm_guess</em>, <em>background_guess=None</em>, <em>background_guess_err=0.0</em>, <em>aper_coeff=3.0</em>, <em>warn=True</em>, <em>x_guess=None</em>, <em>y_guess=None</em>, <em>return_surfaces=False</em>, <em>aperture_surface=None</em>, <em>annulus_surface=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the aperture photometry of a star centered in a star box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>star_box</strong> – Star box</li>
<li><strong>fwhm_guess</strong> – Guessed FWHM. Used to get the aperture radius.</li>
<li><strong>background_guess</strong> – (Optional) If not None, this guess is
used instead of the background determination in an annulus
around the star (default None).</li>
<li><strong>background_guess_err</strong> – (Optional) Error on the background
guess. Used to compute the aperture photometry error (default 0.).</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for Moffat stars with a high SNR).</li>
<li><strong>warn</strong> – (Optional) If True, print a warning when the background cannot
be well estimated (default True).</li>
<li><strong>x_guess</strong> – (Optional) position of the star along x axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><strong>y_guess</strong> – (Optional) position of the star along y axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><strong>return_surfaces</strong> – (Optional) If True returns also the
aperture_surface and annulus_surface computed. Useful if
multiple stars with the same FWHM must be done (default False).</li>
<li><strong>aperture_surface</strong> – (Optional) Pre-computed
aperture_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if aperture_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
<li><strong>annulus_surface</strong> – (Optional) Pre-computed
annulus_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if annulus_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Tuple (flux, flux_error, aperture surface,
bad_estimation_flag). If the estimation is bad,
bad_estimation_flat is set to 1, else it is set to 0.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best aperture for maximum S/N: 1. FWHM (Howell 1989,
Howell 1992). But that works only when the PSF is well sampled
which is not always the case so a higher aperture coefficient
may be better. More over, to get exact photometry the result
must be corrected by aperture growth curve for the ‘missing
light’. A coefficient of 1.27 FWHM corresponds to 3 sigma and
collects more than 99% of the light if the star is a pure
Gaussian. A coefficient of 3 for Moffat stars reduces the
variations of the proportion of collected photons when the FWHM
is changing and seems to be the best.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best radius for sky background annulus is determined
from this rule of thumb: The number of pixels to estimate the
background must be al least 3 times the number of pixel in the
aperture (Merline &amp; Howell 1995). Choosing the aperture radius
coefficient(Cap) as Rap = Cap * FWHM and the inner radius
coefficient (Cin) as Rin = Cin * FWHM, gives the outer radius
coefficient (Cout): Cout = sqrt(3*Cap^2 + Cin^2)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The star MUST be at the center (+/- 1 pixel) of the
star box.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.brute_force_guess">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">brute_force_guess</code><span class="sig-paren">(</span><em>image</em>, <em>star_list</em>, <em>x_range</em>, <em>y_range</em>, <em>r_range</em>, <em>rc</em>, <em>zoom_factor</em>, <em>box_size</em>, <em>verbose=True</em>, <em>init_wcs=None</em>, <em>raise_border_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.brute_force_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a precise alignment guess by brute force.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list</strong> – List of star position. Must be given in pixels
if no wcs is given (wcs set to None). If a wcs is given must be a
list of ra/dec coordinates.</li>
<li><strong>x_range</strong> – range of x values to check</li>
<li><strong>y_range</strong> – range of y values to check</li>
<li><strong>r_range</strong> – range of angle values to check</li>
<li><strong>rc</strong> – rotation center (rc, ry). If a WCS is given the
rotation center is obtaind from the wcs itself and must be set to
None.</li>
<li><strong>zoom_factor</strong> – zoom_factor</li>
<li><strong>verbose</strong> – (Optional) If True, print some informations
(default True).</li>
<li><strong>init_wcs</strong> – (Optional) WCS instance (can contain an SIP distortion
model, default None).</li>
<li><strong>raise_border_error</strong> – (Optional) if True raise an exception
if the returned guess is on the border of the brute force grid
(defaut True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.compute_radec_pm">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">compute_radec_pm</code><span class="sig-paren">(</span><em>ra_deg</em>, <em>dec_deg</em>, <em>pm_ra_mas</em>, <em>pm_dec_mas</em>, <em>yr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.compute_radec_pm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute RA/DEC in degrees with proper motion values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ra_deg</strong> – RA in degrees</li>
<li><strong>dec_deg</strong> – DEC in degrees</li>
<li><strong>pm_ra_mas</strong> – Proper motion along RA axis in mas/yr</li>
<li><strong>pm_dec_mas</strong> – Proper motion along DEC axis in mas/yr</li>
<li><strong>yr</strong> – Number of years</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.create_wcs">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">create_wcs</code><span class="sig-paren">(</span><em>target_x</em>, <em>target_y</em>, <em>deltax</em>, <em>deltay</em>, <em>target_ra</em>, <em>target_dec</em>, <em>rotation</em>, <em>sip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.create_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a WCS with an optional SIP distortion model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wcs</strong> – Original WCS. If None, a 2 axis WCS is created instead.</li>
<li><strong>target_x</strong> – Target X position in pixels</li>
<li><strong>target_y</strong> – Target Y position in pixels</li>
<li><strong>deltax</strong> – Plate scale in arcdeg / pixel along X axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</li>
<li><strong>deltax</strong> – Plate scale in arcdeg / pixel along Y axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</li>
<li><strong>target_ra</strong> – Target RA</li>
<li><strong>target_dec</strong> – Target DEC</li>
<li><strong>rotation</strong> – Rotation angle</li>
<li><strong>sip</strong> – (Optional) astropy.WCS instance containing a valid SIP.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.dec2deg">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">dec2deg</code><span class="sig-paren">(</span><em>dec</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.dec2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in sexagesimal format to degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dec</strong> – DEC in sexagesimal format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.deg2dec">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">deg2dec</code><span class="sig-paren">(</span><em>deg</em>, <em>string=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in degrees to sexagesimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – DEC in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.deg2ra">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">deg2ra</code><span class="sig-paren">(</span><em>deg</em>, <em>string=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2ra" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in degrees to sexagesimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – RA in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.detect_fwhm_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">detect_fwhm_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>fwhm_guess_pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.detect_fwhm_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect stars FWHM in a frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">star positions must be known precisely</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frame</strong> – Frame</li>
<li><strong>star_list</strong> – List of the positions of the stars used to
detect FWHM.</li>
<li><strong>fwhm_guess_pix</strong> – Initial guess on the FWHM of the stars.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(FWHM, FWHM_ERR) in pixels</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_sip">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_sip</code><span class="sig-paren">(</span><em>dimx</em>, <em>dimy</em>, <em>scale</em>, <em>star_list1</em>, <em>star_list2</em>, <em>params=None</em>, <em>init_sip=None</em>, <em>err=None</em>, <em>sip_order=4</em>, <em>crpix=None</em>, <em>crval=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>FIT the distortion correction polynomial to match two lists
of stars (the list of stars 2 is distorded to match the list
of stars 1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimx</strong> – X dimension of the image</li>
<li><strong>dimy</strong> – Y dimension of the image</li>
<li><strong>scale</strong> – Plate scale of the image in arcseconds</li>
<li><strong>star_list1</strong> – list of stars 1</li>
<li><strong>star_list2</strong> – list of stars 2</li>
<li><strong>params</strong> – (Optional) Transformation parameter to go from
the list of stars 1 to the list of stars 2. Must be a tuple
[dx, dy, dr, da, db, rcx, rcy, zoom_factor] (default None).</li>
<li><strong>init_sip</strong> – (Optional) Initial SIP (an astropy.wcs.WCS object,
default None)</li>
<li><strong>err</strong> – (Optional) error on the star positions of the star
list 2 (default None).</li>
<li><strong>sip_order</strong> – (Optional) SIP order (default 3).</li>
<li><strong>crpix</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</li>
<li><strong>crval</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_star">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_star</code><span class="sig-paren">(</span><em>star_box</em>, <em>profile_name='gaussian'</em>, <em>fwhm_pix=None</em>, <em>amp=None</em>, <em>beta=3.5</em>, <em>height=None</em>, <em>pos=None</em>, <em>fix_height=False</em>, <em>fix_amp=False</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>fix_pos=False</em>, <em>fit_tol=0.001</em>, <em>check=True</em>, <em>fwhm_min=0.5</em>, <em>check_reject=False</em>, <em>ron=10.0</em>, <em>dcl=0.0</em>, <em>estimate_local_noise=True</em>, <em>precise_guess=False</em>, <em>saturation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a single star</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_box</strong> – The box where the star has to be fitted.</li>
<li><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</li>
<li><strong>amp</strong> – (Optional) Amplitude guess, replace the value of the
automatic estimation (default None).</li>
<li><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><strong>height</strong> – (Optional) Height guess, replace the value of the
automatic estimation (default None).</li>
<li><strong>pos</strong> – (Optional) Position guess as a tuple (x,y), replace
the value of the automatic estimation (default None).</li>
<li><strong>fix_amp</strong> – (Optional) Fix amplitude parameter to its
estimation (default False)</li>
<li><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation (default False)</li>
<li><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</li>
<li><strong>fix_fwhm</strong> – (Optional) Fix FWHM to its estimation (default
False).</li>
<li><strong>fix_pos</strong> – (Optional) Fix position parameters (x,y) at their
estimated value (default False).</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><strong>check</strong> – (Optional) If True, check fit results for oddities
(default True).</li>
<li><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM [in pixel] of the
fitted star (default 0.5)</li>
<li><strong>check_reject</strong> – (Optional) [Debug] If True, print the reason
why a fit is rejected (default False).</li>
<li><strong>ron</strong> – (Optional) Readout noise in ADU/pixel (default
10.). estimate_local_noise must be set to False for this noise
to be taken into account.</li>
<li><strong>dcl</strong> – (Optional) Dark current level in ADU/pixel (default
0.). estimate_local_noise must be set to False for this noise to
be taken into account.</li>
<li><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl are thus not used (default True).</li>
<li><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known (default False).</li>
<li><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_stars_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_stars_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>box_size</em>, <em>profile_name='gaussian'</em>, <em>scale=None</em>, <em>fwhm_pix=None</em>, <em>beta=3.5</em>, <em>fit_tol=0.01</em>, <em>fwhm_min=0.5</em>, <em>fix_height=None</em>, <em>fix_aperture_fwhm_pix=None</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>readout_noise=10.0</em>, <em>dark_current_level=0.0</em>, <em>local_background=True</em>, <em>no_aperture_photometry=False</em>, <em>precise_guess=False</em>, <em>aper_coeff=3.0</em>, <em>blur=False</em>, <em>no_fit=False</em>, <em>estimate_local_noise=True</em>, <em>multi_fit=False</em>, <em>enable_zoom=False</em>, <em>enable_rotation=False</em>, <em>saturation=None</em>, <em>fix_pos=False</em>, <em>nozero=False</em>, <em>silent=True</em>, <em>sip=None</em>, <em>background_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_stars_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in a frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<ul class="last simple">
<li>Individual fit mode [multi_fit=False]: Stars are all fit
independantly.</li>
<li>Multi fit mode [multi_fit=True]: Stars are fitted all together
considering that the position pattern is well known, the same
shift in x and y will be applied. Optionally the pattern can be
rotated and zoomed. The FWHM is also considered to be the
same. This option is far more robust and precise for alignment
purpose.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frame</strong> – The frame containing the stars to fit.</li>
<li><strong>star_list</strong> – A list of star positions as an array of shape
(star_nb, 2)</li>
<li><strong>box_size</strong> – The size of the box created around a star to fit
its parameter.</li>
<li><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</li>
<li><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><strong>scale</strong> – (Optional) Scale of the frame in arcsec/pixel. If
given the fwhm in arcseconds is also computed (keyword:
‘fwhm_arc’) with the fit parameters (default None).</li>
<li><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation. If None, set by default to True in individual fit
mode [multi_fit=False] and False in multi fit mode
[multi_fit=True] (default None).</li>
<li><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</li>
<li><strong>fix_fwhm</strong> – (Optional) Fix FWHM to the given value or the
estimated value (default False).</li>
<li><strong>fix_pos</strong> – (Optional) Fix x,y positions of the stars to the
given value.</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><strong>nozero</strong> – (Optional) If True do not fit any star which box
(the pixels around it) contains a zero. Valid only in individual
fit mode [multi_fit=False] (default False).</li>
<li><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM of the fitted star
(default 0.5)</li>
<li><strong>silent</strong> – (Optional) If True no messages are printed (default
True).</li>
<li><strong>local_background</strong> – (Optional) If True, height is estimated
localy, i.e. around the star. If False, the sky background is
determined in the whole frame. In individual fit mode
[multi_fit=False] height will be the same for all the stars, and
the fix_height option is thus automatically set to True. In
multi fit mode [multi_fit=True] height is considered as a
covarying parameter for all the stars but it won’t be fixed
(default True).</li>
<li><strong>fix_aperture_fwhm_pix</strong> – (Optional) If a positive float. FWHM
used to scale aperture size is not computed from the mean FWHM
in the frame but fixed to the given float (default None).</li>
<li><strong>no_aperture_photometry</strong> – (Optional) If True, aperture
photometry will not be done after profile fitting (default
False).</li>
<li><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known. Valid only in individual fit mode
[multi_fit=False] (default False).</li>
<li><strong>readout_noise</strong> – (Optional) Readout noise in ADU/pixel (can
be computed from bias frames: std(master_bias_frame)) (default
10.)</li>
<li><strong>dark_current_level</strong> – (Optional) Dark current level in
ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for star with a high SNR).</li>
<li><strong>blur</strong> – (Optional) If True, blur frame (low pass filtering)
before fitting stars. It can be used to enhance the quality of
the fitted flux of undersampled data. Note that the error on
star position can be greater on blurred frame. This option must
not be used for alignment purpose (default False).</li>
<li><strong>no_fit</strong> – (Optional) If True, no fit is done. Only the
aperture photometry. Star positions in the star list must thus
be precise (default False).</li>
<li><strong>multi_fit</strong> – (Optional) If True all stars are fitted at the
same time. More robust for alignment purpose. The difference of
position between the stars in the star list must be precisely
known because the overall shift only is estimated (default
False).</li>
<li><strong>enable_zoom</strong> – (Optional) If True, the stars position pattern
can be zoomed to better adjust it to the real frame. Valid only
in multi fit mode [multi_fit=True] (default False).</li>
<li><strong>enable_rotation</strong> – (Optional) If True, the stars position
pattern can be rotated to better adjust it to the real frame
Valid only in multi fit mode [multi_fit=True] (default False).</li>
<li><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. readout_noise and dark_current_level are thus not used
(default True).</li>
<li><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
<li><strong>sip</strong> – (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</li>
<li><strong>background_value</strong> – (Optional) If not None, this background
value is used in the fit functions and will be fixed for fit and
aperture photometry. Note also that in this case
local_background is automatically set to False (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Parameters of a 2D fit of the stars positions.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.load_star_list()</span></code> to load
a predefined list of stars or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.detect_stars()</span></code> to automatically
create it.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.astrometry.fit_star()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.cutils.multi_fit_stars()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.get_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">get_profile</code><span class="sig-paren">(</span><em>profile_name</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PSF profile class corresponding to the given profile name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<em>profile</em>) – The name of the PSF profile. Must be ‘moffat’
or ‘gaussian’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.get_wcs_parameters">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">get_wcs_parameters</code><span class="sig-paren">(</span><em>_wcs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_wcs_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return comprehensive parameters from a simple WCS as created
with orb.utils.astrometry.create_wcs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wcs</strong> – An astropy.wcs.WCS instance created with
orb.utils.astrometry.create_wcs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">target_x, target_y, deltax, deltay, target_ra,
target_dec, rotation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.guess">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">guess</code><span class="sig-paren">(</span><em>star_box</em>, <em>pos=None</em>, <em>height=None</em>, <em>precise_pos=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimation of the star parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>star_box</strong> – Sub-part of an image surrounding a star. The
center of the star must be placed near the center of the
box. The dimensions of the box must be greater than 3 times
the FWHM of the star.</li>
<li><strong>pos</strong> – (Optional) Position guess as a tuple (x,y). Used to
estimate amplitude (default None).</li>
<li><strong>height</strong> – (Optional) Guess of the background level. Used to
estimate amplitude (default None).</li>
<li><strong>precise_pos</strong> – (Optional) If True, position is estimated from
the marginal distribution of the PSF. Return a far better
estimation if and only if the star is well centered in the box,
i.e. if and only if the position of the star is already
known. This can lead to errors when trying to find the star in
the box, in this case precise_pos must be set to False (default
False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[height,amplitude,x,y,width]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.histogram_registration">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">histogram_registration</code><span class="sig-paren">(</span><em>star_list1</em>, <em>star_list2</em>, <em>dimx</em>, <em>dimy</em>, <em>xy_bins</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.histogram_registration" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast histogram registration of an image based on the comparison
of two star lists: one created from the real star position in the
image and the other from, e.g. a catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list1</strong> – first list of stars</li>
<li><strong>star_list2</strong> – second list of stars</li>
<li><strong>dimx</strong> – X dimension of the image in pixels</li>
<li><strong>dimy</strong> – Y dimension of the image inp ixels</li>
<li><strong>xy_bins</strong> – number of bins along X and Y</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This kind of registration is very sensitive to the
angle between each list. It is better to use it on a range of
angles (steps of 0.5 degree) to make sure the best correlation
is found.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.load_star_list">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">load_star_list</code><span class="sig-paren">(</span><em>star_list_path</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.load_star_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of stars coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> – The path to the star list file.</li>
<li><strong>silent</strong> – (Optional) If True no message is printed (default
False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A list of stars is a list of star coordinates (x and
y). Each set of coordinates is separated by a line
break. There must not be any blank line or comments.</p>
<p>For example:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">221.994164678</span> <span class="mf">62.8374036151</span>
<span class="mf">135.052291354</span> <span class="mf">274.848787038</span>
<span class="mf">186.478298303</span> <span class="mf">11.8162949818</span>
<span class="mf">362.642981933</span> <span class="mf">323.083868198</span>
<span class="mf">193.546595814</span> <span class="mf">321.017948051</span>
</pre></div>
</div>
</div>
<p>The star list can be created using DS9
(<a class="reference external" href="http://hea-www.harvard.edu/RD/ds9/site/Home.html">http://hea-www.harvard.edu/RD/ds9/site/Home.html</a>) on the
first image of the sequence :</p>
<blockquote>
<div><ol class="arabic simple">
<li>Select more than 3 stars with the circular tool (the
more you select, the better will be the alignment)</li>
<li>Save the regions you have created with the options:<ul>
<li>Format = ‘XY’</li>
<li>Coordinate system = ‘Image’</li>
</ul>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.mag">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">mag</code><span class="sig-paren">(</span><em>flux</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.mag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return the instrumental magnitude of a given flux (magnitude 0</dt>
<dd>is set to 1 e-)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flux</strong> – Flux in e-</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.multi_aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">multi_aperture_photometry</code><span class="sig-paren">(</span><em>frame</em>, <em>pos_list</em>, <em>fwhm_guess_pix</em>, <em>aper_coeff=3.0</em>, <em>detect_fwhm=False</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.multi_aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Aperture photometry of multiple sources in a frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame</li>
<li><strong>pos_list</strong> – List of the positions of the sources</li>
<li><strong>fwhm_guess_pix</strong> – Initial guess on the FWHM of the sources.</li>
<li><strong>aper_coeff</strong> – (Optional) Aperture coefficient used for
photometry (default 3.).</li>
<li><strong>detect_fwhm</strong> – (Optional) If True FWHM is automatically
computed from a fit on the sources. Sources must be stars or
bright point sources. If most of the sources are stars this
might work well enough (default False).</li>
<li><strong>silent</strong> – (Optional) Silent function if True (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.pix2world">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">pix2world</code><span class="sig-paren">(</span><em>hdr</em>, <em>dimx</em>, <em>dimy</em>, <em>star_list_pix</em>, <em>dxmap</em>, <em>dymap</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.pix2world" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel positions to RA/DEC coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – pyfits.Header instance</li>
<li><strong>dimx</strong> – Image dimension along X</li>
<li><strong>dimy</strong> – Image dimension along Y</li>
<li><strong>star_list_pix</strong> – List of star coordinates in pixels</li>
<li><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</li>
<li><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.ra2deg">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">ra2deg</code><span class="sig-paren">(</span><em>ra</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.ra2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in sexagesimal format to degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ra</strong> – RA in sexagesimal format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.radial_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">radial_profile</code><span class="sig-paren">(</span><em>a</em>, <em>xc</em>, <em>yc</em>, <em>rmax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.radial_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average radial profile on a region of a 2D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A 2D array</li>
<li><strong>xc</strong> – Center of the profile along x axis</li>
<li><strong>yc</strong> – Center of the profile along y axis</li>
<li><strong>rmax</strong> – Radius of the profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(R axis, V axis). A tuple of 2 vectors giving the radius
axis and the corresponding values axis.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.realign_images">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">realign_images</code><span class="sig-paren">(</span><em>_cube</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.realign_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Realign images of a small cube of images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>_cube</strong> – A 3 dimensional np.ndarray.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This procedure is robust but very slow. Do not use it
to realign a large number of images.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.sky_background_level">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">sky_background_level</code><span class="sig-paren">(</span><em>im</em>, <em>smooth_coeff=0.1</em>, <em>return_mode=False</em>, <em>bins=25</em>, <em>return_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sky_background_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the sky background based on the maximum of
the histogram of the pixels distribution in the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image.</li>
<li><strong>smooth_coeff</strong> – (Optional) the smoothing degree, i.e. the
number of smoothing points is defined by smooth_coeff *
size(histogram) (default 0.05). If smooth_coeff &lt;= 0. no
smoothing is applied.</li>
<li><strong>return_mode</strong> – (Optional) If True the returned value is the
mode (an entire value for a distribution of integers). If False,
return the mean of a sigmacut realized around the mode (a
fractional value, generally more precise).</li>
<li><strong>bins</strong> – (Optional) Number of bins for the histogram (default
20).</li>
<li><strong>return_error</strong> – (Optional) If True, the error on the
estimation is returned (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.transform_star_position_A_to_B">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">transform_star_position_A_to_B</code><span class="sig-paren">(</span><em>star_list_A</em>, <em>params</em>, <em>rc</em>, <em>zoom_factor</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the positions in camera
B given the transformation parameters.</p>
<p>Optionally SIP distorsion parameters can be given.</p>
<p>The transformation steps are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dist_pix_camA</span> <span class="o">-&gt;</span> <span class="n">perf_pix_camA</span> <span class="o">-&gt;</span> <span class="n">geometric</span> <span class="n">transformation_A2B</span>
<span class="o">-&gt;</span> <span class="n">perf_pix_camB</span> <span class="o">-&gt;</span> <span class="n">dist_pix_camB</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_A</strong> – List of star coordinates in the cube A.</li>
<li><strong>params</strong> – Transformation parameters [dx, dy, dr, da, db].</li>
<li><strong>rc</strong> – Rotation center coordinates.</li>
<li><strong>zoom_factor</strong> – Zooming factor between the two cameras. Can be
a couple (zx, zy).</li>
<li><strong>sip_A</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame A (default None).</li>
<li><strong>sip_B</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame B (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.world2pix">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">world2pix</code><span class="sig-paren">(</span><em>hdr</em>, <em>dimx</em>, <em>dimy</em>, <em>star_list_deg</em>, <em>dxmap</em>, <em>dymap</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.world2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA/DEC coordinates to pixel positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – pyfits.Header instance</li>
<li><strong>dimx</strong> – Image dimension along X</li>
<li><strong>dimy</strong> – Image dimension along Y</li>
<li><strong>star_list_deg</strong> – List of star coordinates in degrees</li>
<li><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</li>
<li><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.err">
<span id="orb-utils-err-module"></span><h2>orb.utils.err module<a class="headerlink" href="#module-orb.utils.err" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="orb.utils.err.FitError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitError</code><a class="headerlink" href="#orb.utils.err.FitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.FitInitError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitInitError</code><a class="headerlink" href="#orb.utils.err.FitInitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.FitInputError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">FitInputError</code><a class="headerlink" href="#orb.utils.err.FitInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.ORBError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">ORBError</code><a class="headerlink" href="#orb.utils.err.ORBError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.RuntimeError</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="orb.utils.err.ValidationError">
<em class="property">exception </em><code class="descclassname">orb.utils.err.</code><code class="descname">ValidationError</code><a class="headerlink" href="#orb.utils.err.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fft">
<span id="orb-utils-fft-module"></span><h2>orb.utils.fft module<a class="headerlink" href="#module-orb.utils.fft" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.fft.amplitude">
<code class="descclassname">orb.utils.fft.</code><code class="descname">amplitude</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amplitude of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.apod2sigma">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apod2sigma</code><span class="sig-paren">(</span><em>apod</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the broadening of the gaussian-sinc function in the
spectrum for a given apodization level. Unit is that of the fwhm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>apod</strong> – Apodization level (must be &gt;= 1.)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.apod2width">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apod2width</code><span class="sig-paren">(</span><em>apod</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the gaussian window for a given apodization level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>apod</strong> – Apodization level (must be &gt;= 1.)</td>
</tr>
</tbody>
</table>
<p>The apodization level is the broadening factor of the line (an
apodization level of 2 mean that the line fwhm will be 2 times
wider).</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.apodize">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apodize</code><span class="sig-paren">(</span><em>s</em>, <em>apodization_function=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apodize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apodize a spectrum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> – Spectrum</li>
<li><strong>apodization_function</strong> – (Optional) A Norton-Beer apodization
function (default 2.0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.border_cut_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">border_cut_window</code><span class="sig-paren">(</span><em>n</em>, <em>coeff=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Window length</li>
<li><strong>coeff</strong> – Border size in percentage of the total length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.calib_map2phase_map0">
<code class="descclassname">orb.utils.fft.</code><code class="descname">calib_map2phase_map0</code><span class="sig-paren">(</span><em>p</em>, <em>calib_map</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.calib_map2phase_map0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute order 0 phase map from calibration laser map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> – Transformation parameters [a0, a1]</li>
<li><strong>calib_map</strong> – Calibration laser map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.compute_phase_coeffs_vector">
<code class="descclassname">orb.utils.fft.</code><code class="descname">compute_phase_coeffs_vector</code><span class="sig-paren">(</span><em>phase_maps</em>, <em>res_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.compute_phase_coeffs_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector containing the mean of the phase
coefficients for each given phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phase_maps</strong> – Tuple of phase maps. Coefficients are
sorted in the same order as the phase maps.</li>
<li><strong>res_map</strong> – (Optional) If given this map is used to
get only the well fitted coefficients in order to compute a
more precise mean coefficent.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.count_nonzeros">
<code class="descclassname">orb.utils.fft.</code><code class="descname">count_nonzeros</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.count_nonzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of nonzeros parts in a vector as a vector of
the same length with the length of each part at each occurence of
a nonzero number.</p>
<p>e.g. : if a = [0,0,0,1,1,0,1] this function returns: [0,0,0,2,2,0,1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> – A vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.create_phase_file">
<code class="descclassname">orb.utils.fft.</code><code class="descname">create_phase_file</code><span class="sig-paren">(</span><em>file_path</em>, <em>phase_vector</em>, <em>cm1_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.create_phase_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a phase vector in a phase file.</p>
<p>Phase vector is interpolated via a cubic spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the output phase file.</li>
<li><strong>phase_vector</strong> – Phase vector</li>
<li><strong>cm1_axis</strong> – Phase vector axis in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.cube_raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">cube_raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Interferogram cube</li>
<li><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.gaussian_window()</span></code> (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.find_zpd">
<code class="descclassname">orb.utils.fft.</code><code class="descname">find_zpd</code><span class="sig-paren">(</span><em>interf</em>, <em>step_number=None</em>, <em>return_zpd_shift=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.find_zpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the ZPD along the z axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_number</strong> – (Optional) If the full number of steps is
greater than the number of frames of the cube. Useful when
the interferograms are non symetric (default None).</li>
<li><strong>return_zpd_shift</strong> – (Optional) If True return ZPD shift
instead of ZPD index (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.gaussian_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">gaussian_window</code><span class="sig-paren">(</span><em>coeff</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.gaussian_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian apodization function for a given broadening
factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coeff</strong> – FWHM relative to the sinc function. Must be a float &gt; 1.</li>
<li><strong>x</strong> – Must be an axis defnined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.imag">
<code class="descclassname">orb.utils.fft.</code><code class="descname">imag</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.indft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">indft</code><span class="sig-paren">(</span><em>a</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – regularly sampled spectrum.</li>
<li><strong>x</strong> – positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.interf_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">interf_mean_energy</code><span class="sig-paren">(</span><em>interf</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interf</strong> – an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.learner95_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">learner95_window</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – Must be an axis defnined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.ndft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">ndft</code><span class="sig-paren">(</span><em>a</em>, <em>xk</em>, <em>vj</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.ndft" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-uniform Discret Fourier Tranform</p>
<p>Compute the spectrum from an interferogram. Note that the axis can
be irregularly sampled.</p>
<p>If the spectral axis (output axis) is irregular the result is
exact. But there is no magic: if the input axis (interferogram
sampling) is irregular the output spectrum is not exact because
the projection basis is not orthonormal.</p>
<p>If the interferogram is the addition of multiple regularly sampled
scans with a opd shift between each scan, the result will be good
as long as there are not too much scans added one after the
other. But if the interferogram steps are randomly distributed, it
will be better to use a classic FFT because the resulting noise
will be much lower.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – 1D interferogram</li>
<li><strong>xk</strong> – 1D sampling steps of the interferogram. Must have the
same size as a and must be relative to the real step length,
i.e. if the sampling is uniform xk = np.arange(a.size).</li>
<li><strong>vj</strong> – 1D frequency sampling of the output spectrum.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.next_power_of_two">
<code class="descclassname">orb.utils.fft.</code><code class="descname">next_power_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> – The number from which the next power of two has to be
computed. Can be an array of numbers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.norton_beer_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">norton_beer_window</code><span class="sig-paren">(</span><em>fwhm='1.6'</em>, <em>n=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id1">[NAY2007]</a>).</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm</strong> – FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default ‘1.6’)</li>
<li><strong>n</strong> – Number of points (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id2">[NAY2007]</a> :</p>
<table border="1" class="last docutils">
<colgroup>
<col width="8%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FWHM</td>
<td>C0</td>
<td>C1</td>
<td>C2</td>
<td>C4</td>
<td>C6</td>
<td>C8</td>
</tr>
<tr class="row-even"><td>1.1</td>
<td>0.701551</td>
<td>-0.639244</td>
<td>0.937693</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td>0.396430</td>
<td>-0.150902</td>
<td>0.754472</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td>0.237413</td>
<td>-0.065285</td>
<td>0.827872</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.4</td>
<td>0.153945</td>
<td>-0.141765</td>
<td>0.987820</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.5</td>
<td>0.077112</td>
<td>0.000000</td>
<td>0.703371</td>
<td>0.219517</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.6</td>
<td>0.039234</td>
<td>0.000000</td>
<td>0.630268</td>
<td>0.234934</td>
<td>0.095563</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.7</td>
<td>0.020078</td>
<td>0.000000</td>
<td>0.480667</td>
<td>0.386409</td>
<td>0.112845</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.8</td>
<td>0.010172</td>
<td>0.000000</td>
<td>0.344429</td>
<td>0.451817</td>
<td>0.193580</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.9</td>
<td>0.004773</td>
<td>0.000000</td>
<td>0.232473</td>
<td>0.464562</td>
<td>0.298191</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>2.0</td>
<td>0.002267</td>
<td>0.000000</td>
<td>0.140412</td>
<td>0.487172</td>
<td>0.256200</td>
<td>0.113948</td>
</tr>
</tbody>
</table>
</div>
<table class="docutils citation" frame="void" id="nay2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NAY2007]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.optimize_phase">
<code class="descclassname">orb.utils.fft.</code><code class="descname">optimize_phase</code><span class="sig-paren">(</span><em>interf, step, order, zpd_index, calib, nm_laser, guess=[0.0001, 0.0001], return_coeffs=False, fixed_params=[0, 0], weights=None, high_order_phase=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.optimize_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optimized phase vector based on the minimization of
the imaginary part.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>interf</strong> – Interferogram</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Alisasing order</li>
<li><strong>zpd_index</strong> – ZPD index</li>
<li><strong>calib</strong> – Calibration laser observed wavelength</li>
<li><strong>nm_laser</strong> – Calibration laser real wavelength</li>
<li><strong>guess</strong> – (Optional) First guess. The number of values defines the order
of the polynomial used used to fit (default [0,0]).</li>
<li><strong>return_coeffs</strong> – (Optional) If True, coeffs and residual are
returned instead of the phase vector (default False).</li>
<li><strong>fixed_params</strong> – (Optional) Define free and fixed parameters
(1 for fixed, 0 for free, default [0,0])</li>
<li><strong>weights</strong> – (Optional) spectrum weighting (a vector with
values ranging from 0 to 1, 1 being the maximum weight)</li>
<li><strong>high_order_phase</strong> – (Optional) High order phase to be
subtracted during the optimization process. Must be a
orb.core.PhaseFile instance or a
scipy.interpolate.UnivariateSpline instance to accelerate the
process (as returned by
<a class="reference internal" href="#orb.utils.fft.read_phase_file" title="orb.utils.fft.read_phase_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.fft.read_phase_file()</span></code></a>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.optimize_phase3d">
<code class="descclassname">orb.utils.fft.</code><code class="descname">optimize_phase3d</code><span class="sig-paren">(</span><em>interf_cube</em>, <em>step</em>, <em>order</em>, <em>zpd_shift</em>, <em>calib_map</em>, <em>nm_laser</em>, <em>high_order_phase</em>, <em>pm0=None</em>, <em>pm1=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.optimize_phase3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 3 coefficents that define the linear phase terms (p0
+ p1 * x).</p>
<p>The optimization is based on the maximization of the real part of
the spectrum. It is done on the complete interferogram cube (a
binned version is much faster) with a given calibration map. In
this process the calibration map is considered to be exact and the
order 0 phase map is directly calculated from it unless a phase
map is given.</p>
<p>This method is very efficient for cubes with poor phase
informations in each pixel: e.g. extended galactic nebula that
covers the whole field of view.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>interf_cube</strong> – Interferogram cube</li>
<li><strong>step</strong> – Step size</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>zpd_shift</strong> – ZPD shift</li>
<li><strong>calib_map</strong> – Calibration laser map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength</li>
<li><strong>high_order_phase</strong> – A scipy.Spline instance of the high order
phase or an orb.core.PhaseFile instance.</li>
<li><strong>pm0</strong> – (Optional) Order 0 phase map. This map is adjusted
instead of calculating a phase map from a calibration laser
frame (default None).</li>
<li><strong>pm1</strong> – (Optional) Order 1 phase map. This map is adjusted
instead of considering a single order 1 coefficient (default
None). WARNING: this phase map must be in a “portable format”,
i.e.: it must have been multiplied by the number of steps of the
original cube.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Phase map coefficients (a0, a1, p1) if the phase map has
to be calculated from the calibration map (pm0 set to None) or
(a0, p1) if the order 0 phase map is given</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.phase">
<code class="descclassname">orb.utils.fft.</code><code class="descname">phase</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the phase of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.phase_map02calib_map">
<code class="descclassname">orb.utils.fft.</code><code class="descname">phase_map02calib_map</code><span class="sig-paren">(</span><em>p</em>, <em>phase_map0</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.phase_map02calib_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute calibration laser map from order 0 phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> – Transformation parameters [a0, a1]</li>
<li><strong>calib_map</strong> – Order 0 phase map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em>, <em>inverse=False</em>, <em>return_complex=False</em>, <em>return_phase=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector.</p>
<p>Return the absolute value of the complex vector by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Interferogram.</li>
<li><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.norton_beer_window()</span></code> (default None)</li>
<li><strong>inverse</strong> – (Optional) If True compute the inverse FFT
(default False).</li>
<li><strong>return_complex</strong> – (Optional) If True, the complex vector is
returned (default False).</li>
<li><strong>return_phase</strong> – (Optional) If True, the phase is
returned.(default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.read_phase_file">
<code class="descclassname">orb.utils.fft.</code><code class="descname">read_phase_file</code><span class="sig-paren">(</span><em>file_path</em>, <em>return_spline=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.read_phase_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a basic phase file and return its content.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – Path to the phase file</li>
<li><strong>return_spline</strong> – If True a cubic spline
(scipy.interpolate.UnivariateSpline instance) is returned
instead of a tuple.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (Phase axis [cm-1], Phase [radians]) or a
scipy.interpolate.UnivariateSpline instance if return_spline is
True.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.real">
<code class="descclassname">orb.utils.fft.</code><code class="descname">real</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.spectrum_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em>spectrum</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spectrum</strong> – a 1D spectrum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.transform_interferogram">
<code class="descclassname">orb.utils.fft.</code><code class="descname">transform_interferogram</code><span class="sig-paren">(</span><em>interf</em>, <em>nm_laser</em>, <em>calibration_nm_laser</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>phase_correction=True</em>, <em>wave_calibration=True</em>, <em>return_phase=False</em>, <em>ext_phase=None</em>, <em>balanced=True</em>, <em>bad_frames_vector=None</em>, <em>smoothing_coeff=0.04</em>, <em>return_complex=False</em>, <em>final_step_nb=None</em>, <em>wavenumber=False</em>, <em>low_order_correction=False</em>, <em>high_order_phase=None</em>, <em>return_zp_vector=False</em>, <em>sampling_steps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.transform_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an interferogram into a spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>interf</strong> – Interferogram to transform.</li>
<li><strong>nm_laser</strong> – Wavelength of the laser used for calibration.</li>
<li><strong>calibration_nm_laser</strong> – Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><strong>step</strong> – Step size of the moving mirror in nm.</li>
<li><strong>order</strong> – Folding order (if 0 the result cannot be projected
on an axis in nm, i.e. wavenumber option is automatically set to
True).</li>
<li><strong>window_type</strong> – Name of the apodization function (can be
learner95 or a float &gt; 1.).</li>
<li><strong>zpd_shift</strong> – Shift of the interferogram to center the ZPD.</li>
<li><strong>bad_frames_vector</strong> – (Optional) Mask-like vector containing
ones for bad frames. Bad frames are replaced by zeros using a
special function that smoothes transition between good parts and
zeros (default None). This vector must be uncorrected for ZPD
shift</li>
<li><strong>phase_correction</strong> – (Optional) If False, no phase correction
will be done and the resulting spectrum will be the absolute
value of the complex spectrum. Else the ext_phase vector will be
used for phase correction. If ext_phase is set to None,
ext_phase will be replaced by a vector of 0 (default True).</li>
<li><strong>wave_calibration</strong> – (Optional) If True wavenumber/wavelength
calibration is done (default True).</li>
<li><strong>ext_phase</strong> – (Optional) External phase vector. If given this
phase vector is used instead of a low-resolution one. It must be
as long as the interferogram.</li>
<li><strong>return_phase</strong> – (Optional) If True, compute only the phase of
the interferogram and return it. If polyfit_deg is &gt;= 0, return
the coefficients of the fitted phase (default False). Note that
this option is not compatible with ext_phase. You must set
ext_phase to None to set return_phase to True.</li>
<li><strong>smoothing_coeff</strong> – (Optional) Coefficient of zeros smoothing
in proportion of the total interferogram size. A higher
coefficient means a smoother transition from zeros parts (bad
frames) to non-zero parts (good frames) of the
interferogram. Good parts on the other side of the ZPD in
symmetry with zeros parts are multiplied by 2 to keep a constant
amount of energy. The same transition is used to multiply
interferogram points by zero and 2. This operation is not done
if smoothing_coeff is set to 0. must be between 0. and 0.2
(default 0.04).</li>
<li><strong>balanced</strong> – (Optional) If False, the interferogram is
considered as unbalanced. It is flipped before its
transformation to get a positive spectrum. Note
that a merged interferogram is balanced (default True).</li>
<li><strong>return_complex</strong> – (Optional) If True and if phase is
corrected the returned spectrum will be complex. In False only
the real part is returned (default False)</li>
<li><strong>final_step_nb</strong> – (Optional) Number of samples of the
resulting spectrum. If None, the number of samples of the
spectrum will be the same as the interferogram (default None).</li>
<li><strong>wavenumber</strong> – (Optional) If True, the returned spectrum is
projected onto its original wavenumber axis (emission lines and
especially unapodized sinc emission lines are thus symetric
which is not the case if the spectrum is projected onto a, more
convenient, regular wavelength axis) (default False).</li>
<li><strong>low_order_correction</strong> – (Optional) If True substract a low
order polynomial to remove low frequency noise. Useful for
unperfectly corrected interferograms (default False).</li>
<li><strong>high_order_phase</strong> – (Optional) High order phase to be added
to the phase computed via a low order polynomial (generally 1
order). Note that it must be a orb.core.PhaseFile instance or a
scipy.interpolate.UnivariateSpline instance to accelerate the
process.</li>
<li><strong>sampling_steps</strong> – (Optional) If the sampling steps are not
uniform, the real sampling function can be given. It must have
the exact same size as the interferogram. Note that a NDFT will
be performed which is much slower than a FFT.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only NANs or INFs are interpreted as bad values</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.transform_spectrum">
<code class="descclassname">orb.utils.fft.</code><code class="descname">transform_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>nm_laser</em>, <em>calibration_nm_laser</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>ext_phase=None</em>, <em>return_complex=False</em>, <em>wavenumber=False</em>, <em>final_step_nb=None</em>, <em>sampling_vector=None</em>, <em>zero_padding=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.transform_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a spectrum into an interferogram.</p>
<p>This function is the inverse of <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>.</p>
<p>So that to get the initial interferogram, the same options used in
transform interferogram must be passed to this function. The
spectrum must also be the complex form (use return_complex option
in <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>spectrum</strong> – Spectrum to transform</li>
<li><strong>nm_laser</strong> – Wavelength of the laser used for calibration.</li>
<li><strong>calibration_nm_laser</strong> – Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><strong>step</strong> – Step size of the moving mirror in nm.</li>
<li><strong>order</strong> – Folding order (can be 0 but the input must be in
wavenumber).</li>
<li><strong>window_type</strong> – Name of the apodization function.</li>
<li><strong>zpd_shift</strong> – Shift of the interferogram to decenter the ZPD.</li>
<li><strong>ext_phase</strong> – (Optional) External phase vector. If given this
phase vector is used in place of the original phase of the
spectrum. Useful to add a phase to an interferogram. Note that
this phase is intended to be used to inverse transform an
already transformed interferogram. The computed phase correction
can thus be used directly. As the phase vector given by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code> is not reversed for
even orders, it is reversed here in this function.</li>
<li><strong>return_complex</strong> – (Optional) If True return a complex
interferogram. Else return the real part of it (default False).</li>
<li><strong>wavenumber</strong> – (Optional) If True the spectrum axis is in
cm-1. In this case, and if no wavelength correction has to be
applied (calibration_nm_laser == nm_laser) there will be no
interpolation of the original spectrum (better precision)
(default False).</li>
<li><strong>final_step_nb</strong> – (Optional) Final size of the
interferogram. Must be less than the size of the original
spectrum. If None the final size of the interferogram is the
same as the size of the original spectrum (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Sampling_vector:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first">(Optional) If the samples of the interferogram
are not uniformly distributed, a vector giving the positions of
the samples can be passed. In this case an inverse NDFT is
computed which may be really slow for long vectors. A uniformly
sampled vector would be range(final_step_nb). The size of the
vector must be equal to final_step_nb (default None).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Zero_padding:</th><td class="field-body"><p class="first last">(Optional) If True and if final_step_nb is &gt;
spectrum step number, ouput is zero padded. Can be used to
compare a high resolution interferogram to a low resolution
interferogram.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.variable_me">
<code class="descclassname">orb.utils.fft.</code><code class="descname">variable_me</code><span class="sig-paren">(</span><em>n</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.variable_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sinusoidal function representing a variable
modulation efficiency.</p>
<p>This function is used to correct for fringes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> – A tuple of floats [frequency, amplitude,
phase]. The frequency gives the number of repetition of a sinus
over the vector. The amplitude must be between 0. (returns a
vector of 1) and 1. (returns a sinus going from 0 to 1). Phase
can be a single float or a vector of size n</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.filters">
<span id="orb-utils-filters-module"></span><h2>orb.utils.filters module<a class="headerlink" href="#module-orb.utils.filters" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.filters.compute_weights">
<code class="descclassname">orb.utils.filters.</code><code class="descname">compute_weights</code><span class="sig-paren">(</span><em>calib</em>, <em>nm_laser</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>range_border_coeff</em>, <em>filter_min_cm1</em>, <em>filter_max_cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute weights for a fit based on a spectrum with a given
filter bandpass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib</strong> – Calibration laser observed wavelength</li>
<li><strong>nm_laser</strong> – Calibration laser theoretical wavelength</li>
<li><strong>step_nb</strong> – Vector length</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>range_border_coeff</strong> – Percentage of the vector size
considered as bad borders near the filter edges (must be between
0.2 and 0.).</li>
<li><strong>filter_min_cm1</strong> – Minimum wavenumber of the filter in cm-1</li>
<li><strong>filter_max_cm1</strong> – Maximum wavenumber of the filter in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_bandpass">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_bandpass</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the filter bandpass in nm as a tuple (nm_min, nm_max)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>get_filter_bandpass</strong> – Path to the filter file.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_edges_pix">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_edges_pix</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>correction_factor</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>filter_min=None</em>, <em>filter_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_edges_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the position in pixels of the edges of a filter
corrected for the off-axis effect.</p>
<p>Note that the axis is assumed to be in wavenumber.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter_file_path</strong> – Path to the filter file. If None,
filter_min and filter_max must be specified.</li>
<li><strong>step</strong> – Step size of the moving mirror in nm.</li>
<li><strong>order</strong> – Folding order.</li>
<li><strong>correction_factor</strong> – Correction factor
(i.e. calibration_map_value / laser_wavelength)</li>
<li><strong>n</strong> – Number of points of the interpolation axis.</li>
<li><strong>filter_min</strong> – (Optional) Edge min of the filter in nm
(default None).</li>
<li><strong>filter_max</strong> – (Optional) Edge max of the filter in nm
(default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_function">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_function</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>wavenumber=False</em>, <em>silent=False</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a filter file and return its function interpolated over
the desired number of points. Return also the edges position over
its axis in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_file_path</strong> – Path to the filter file.</li>
<li><strong>step</strong> – Step size of the moving mirror in nm.</li>
<li><strong>order</strong> – Folding order.</li>
<li><strong>n</strong> – Number of points of the interpolation axis.</li>
<li><strong>wavenumber</strong> – (Optional) If True the function is interpolated
and returned along a wavenumber axis. If False it is returned
along a wavelength axis (default False).</li>
<li><strong>silent</strong> – (Optional) If True, no message is displayed
(default False).</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(interpolated filter function, min edge, max edge). Min
and max edges are given in pixels over the interpolation axis.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_key">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_key</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>key</em>, <em>cast</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return key value if it exists, None instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter_file_path</strong> – Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_modulation_efficiency">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_modulation_efficiency</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_modulation_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return modulation efficiency if it exists and 1. instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter_file_path</strong> – Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_observation_params">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_observation_params</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_observation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return observation params as tuple (step, order).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter_file_path</strong> – Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_phase_fit_order">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_phase_fit_order</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_phase_fit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return phase fit order if it exists and None instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter_file_path</strong> – Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.read_filter_file">
<code class="descclassname">orb.utils.filters.</code><code class="descname">read_filter_file</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>return_spline=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing the filter transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_file_path</strong> – Path to the filter file.</li>
<li><strong>return_spline</strong> – If True a cubic spline
(scipy.interpolate.UnivariateSpline instance) is returned
instead of a tuple.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(list of filter wavelength, list of corresponding
transmission coefficients, minimum edge of the filter, maximum
edge of the filter) (Both min and max edges can be None if they
were not recorded in the file) or a spline if return_spline set
to True.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The filter file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.  Filter edges can
be specified using the keywords : FILTER_MIN and FILTER_MAX:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## ORBS filter file</span>
<span class="c1"># Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;</span>
<span class="c1"># Filter name : SpIOMM_R</span>
<span class="c1"># Wavelength in nm | Transmission percentage</span>
<span class="c1"># FILTER_MIN 648</span>
<span class="c1"># FILTER_MAX 678</span>
<span class="mi">1000</span> <span class="mf">0.001201585284</span>
<span class="mf">999.7999878</span> <span class="mf">0.009733387269</span>
<span class="mf">999.5999756</span> <span class="o">-</span><span class="mf">0.0004460749624</span>
<span class="mf">999.4000244</span> <span class="mf">0.01378122438</span>
<span class="mf">999.2000122</span> <span class="mf">0.002538740868</span>
</pre></div>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fit">
<span id="orb-utils-fit-module"></span><h2>orb.utils.fit module<a class="headerlink" href="#module-orb.utils.fit" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.fit.gvardict2pickdict">
<code class="descclassname">orb.utils.fit.</code><code class="descname">gvardict2pickdict</code><span class="sig-paren">(</span><em>gvardict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.gvardict2pickdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dictionary containing gvars into a nice pickable
dictionary with couples of _mean / _sdev keys.</p>
<p>Use the pickdict2gvardict to rerturn to the original dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.paramslist2pick">
<code class="descclassname">orb.utils.fit.</code><code class="descname">paramslist2pick</code><span class="sig-paren">(</span><em>paramslist</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.paramslist2pick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.fit.pick2paramslist">
<code class="descclassname">orb.utils.fit.</code><code class="descname">pick2paramslist</code><span class="sig-paren">(</span><em>picklist</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pick2paramslist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.utils.fit.pickdict2gvardict">
<code class="descclassname">orb.utils.fit.</code><code class="descname">pickdict2gvardict</code><span class="sig-paren">(</span><em>pickdict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pickdict2gvardict" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert gvardict2pickdict.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.sigma2vel">
<code class="descclassname">orb.utils.fit.</code><code class="descname">sigma2vel</code><span class="sig-paren">(</span><em>sigma</em>, <em>lines</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.sigma2vel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a broadening in channels to a velocity in km/s
:param sigma: broadening in channels
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fit.vel2sigma">
<code class="descclassname">orb.utils.fit.</code><code class="descname">vel2sigma</code><span class="sig-paren">(</span><em>vel</em>, <em>lines</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.vel2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a velocity in km/s to a broadening in channels.
:param vel: velocity in km/s
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.image">
<span id="orb-utils-image-module"></span><h2>orb.utils.image module<a class="headerlink" href="#module-orb.utils.image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.image.bf_laser_aligner">
<code class="descclassname">orb.utils.image.</code><code class="descname">bf_laser_aligner</code><span class="sig-paren">(</span><em>im1</em>, <em>im2</em>, <em>init_dx</em>, <em>init_dy</em>, <em>init_angle</em>, <em>zf</em>, <em>binning=4</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bf_laser_aligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two complementary laser frames (i.e. cam1 and cam2) with
a brute force algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im1</strong> – frame 1</li>
<li><strong>im2</strong> – frame 2</li>
<li><strong>init_dx</strong> – Initial alignement parameter along X axis</li>
<li><strong>init_dy</strong> – Initial alignement parameter along Y axis</li>
<li><strong>init_angle</strong> – Initial angle</li>
<li><strong>zf</strong> – Zoom factor</li>
<li><strong>binning</strong> – Binning of the data for the first pass</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function returns parameters much different that
the alignement parameters we get from stars… I don’t know why
!</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.check_frames">
<code class="descclassname">orb.utils.image.</code><code class="descname">check_frames</code><span class="sig-paren">(</span><em>frames</em>, <em>sigma_reject=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Set of frames to check</li>
<li><strong>sigma_reject</strong> – (Optional) Rejection coefficient (default 2.5)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.compute_binning">
<code class="descclassname">orb.utils.image.</code><code class="descname">compute_binning</code><span class="sig-paren">(</span><em>image_shape</em>, <em>detector_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.compute_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return binning along both axis given the image shape and the
detector shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image_size</strong> – Tuple [x,y] giving the image shape</li>
<li><strong>detector_shape</strong> – Tuple [x,y] giving the detector shape
(i.e. maximum numbers of pixels along the x and y axis.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_hot_pixels">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_hot_pixels</code><span class="sig-paren">(</span><em>im</em>, <em>hp_map</em>, <em>box_size=3</em>, <em>std_filter_coeff=1.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_hot_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct hot pixels in an image given a map of their position.</p>
<p>The algorithm used replaces a hot pixel value by the median of the
pixels in a box around it. Pixels values which are not too much
different from the values around are not modified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to correct</li>
<li><strong>hp_map</strong> – Hot pixels map (1 for hot pixels, 0 for normal
pixel)</li>
<li><strong>box_size</strong> – (Optional) Size of the correction box (default
3).</li>
<li><strong>std_filter_coeff</strong> – (Optional) Coefficient on the std used to
check if the value of a hot pixel must be changed (default 1.5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_map2d</code><span class="sig-paren">(</span><em>map2d</em>, <em>bad_value=&lt;Mock id='140518076594320'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map2d</strong> – The map to correct</li>
<li><strong>bad_value</strong> – (Optional) Value considered as bad (default
np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>silent=False</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Frames to combine.</li>
<li><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</li>
<li><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</li>
<li><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</li>
<li><strong>silent</strong> – (Optional) If True no information message are
displayed.</li>
<li><strong>check</strong> – (Optional) If True deviating frames are rejected
before combination (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.extract_elliptical_profile">
<code class="descclassname">orb.utils.image.</code><code class="descname">extract_elliptical_profile</code><span class="sig-paren">(</span><em>im</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em>, <em>n=20</em>, <em>percentile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.extract_elliptical_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the elliptical profile of a source</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>im</strong> – Image</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
<li><strong>n</strong> – (Optional) Number of divisions (default 20)</li>
<li><strong>percentile</strong> – (Optional) percentile instead of std. Return
(r, lmedian, [lmin, lmax]). Remember that the 1-sigma percentile
is 15.865 for a gaussian distribution (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first">Y position of the center</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (r, l, lerr) where r is the list of radiuses
along rX, l the mean luminosity in the ellipse portion
corresponding to the radius, lerr the standard deviation of the
luminosity in the same portion of the ellipse.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_calibration_laser_map</code><span class="sig-paren">(</span><em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em>, <em>mirror_distance_guess=240000.0</em>, <em>return_model_fit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a calibration laser map.</p>
<p>Fit an opto-mechanical model first and uses Zernike polynomials to
fit the residual wavefront error.</p>
<p>The model is based on optical parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib_laser_map</strong> – Reference calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Wavelength of the calibration laser in nm.</li>
<li><strong>pixel_size</strong> – (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><strong>binning</strong> – (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
<li><strong>mirror_distance_guess</strong> – (Optional) Guess on the mirror
distance in um (default 2.2e5).</li>
<li><strong>return_model_fit</strong> – (Optional) If True the optical model fit
is also returned (i.e. without the wavefront modeling with Zernike
polynomials) (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_highorder_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_highorder_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>err_map</em>, <em>calib_map</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_highorder_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Robust fit phase maps of order &gt; 1</p>
<p>Uses a theta dependant fit model base on a spline. See
py:meth:<cite>utils.fit_map_cos</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phase_map</strong> – Phase map to fit</li>
<li><strong>err_map</strong> – Error map of phase map values</li>
<li><strong>calib_map</strong> – Calibration laser map.</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple: (Fitted map, residual map)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>smooth_deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit map with low order polynomials</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_map</strong> – data map</li>
<li><strong>err_map</strong> – error map</li>
<li><strong>smooth_deg</strong> – Degree of fit smoothing (beware of high
smoothing degrees)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple: (fitted data map, residual map, fit RMS error)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map_cos">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map_cos</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>calib_map</em>, <em>nm_laser</em>, <em>knb=15</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a map with a theta dependant value. The function f(theta)
is a spline with a given number of knots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_map</strong> – Data map</li>
<li><strong>err_map</strong> – Error map</li>
<li><strong>calib_map</strong> – Calibration laser map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm</li>
<li><strong>knb</strong> – (Optional) Number of knots for the spline (default
10).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map_zernike">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map_zernike</code><span class="sig-paren">(</span><em>data_map</em>, <em>weights_map</em>, <em>nmodes</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_zernike" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a map with Zernike polynomials.</p>
<p>Bad values must be set to NaN (not 0.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_map</strong> – Data map to fit</li>
<li><strong>weights_map</strong> – weights map (high weight value stands for high
precision data)</li>
<li><strong>nmodes</strong> – Number of zernike modes to use for fitting.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(fitted data map, error map, fit error)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_phase_map02calib_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_phase_map02calib_map</code><span class="sig-paren">(</span><em>calib</em>, <em>pm0</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_phase_map02calib_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the best transformation parameters that permit to
compute an order 0 phase map from a calibration laser map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib</strong> – Calibration laser map</li>
<li><strong>pm0</strong> – Order 0 phase map</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_sitelle_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_sitelle_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>phase_map_err</em>, <em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em>, <em>return_coeffs=False</em>, <em>wavefront_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_sitelle_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a SITELLE phase map (order 0 map of the phase) using a
model based on a simulated calibration laser map.</p>
<p>A real calibration laser map is needed first to get an initial guess
on the parameters of the fit. Then the whole phase map is modeled
to fit the real phase map.</p>
<p>The modeled calibration laser map obtained from the fit is also
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phase_map</strong> – Phase map to fit.</li>
<li><strong>phase_map_err</strong> – Error on the phase map values.</li>
<li><strong>calib_laser_map</strong> – Reference calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Wavelength of the calibration laser in nm.</li>
<li><strong>pixel_size</strong> – (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><strong>binning</strong> – (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
<li><strong>return_coeffs</strong> – (Optional) If True, transformation
coefficients are returned also (default False).</li>
<li><strong>wavefront_map</strong> – (Optional) Residual between the modeled
calibration laser map and the real laser map. This residual can
generally be fitted with Zernike polynomials. If given, the
wavefront is considered stable and is removed before the model
is fitted (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (fitted phase map, error map, fit error, new
calibration laser map) + a tuple of transformation coefficients
(a0 and a1) if return_coeffs is True.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.get_box_coords">
<code class="descclassname">orb.utils.image.</code><code class="descname">get_box_coords</code><span class="sig-paren">(</span><em>ix</em>, <em>iy</em>, <em>box_size</em>, <em>x_lim_min</em>, <em>x_lim_max</em>, <em>y_lim_min</em>, <em>y_lim_max</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ix</strong> – center of the box along x axis</li>
<li><strong>iy</strong> – center of the box along y axis</li>
<li><strong>box_size</strong> – Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><strong>x_lim_min</strong> – Minimum limit of the range along x.</li>
<li><strong>x_lim_max</strong> – Maximum limit of the range along x.</li>
<li><strong>y_lim_min</strong> – Minimum limit of the range along y.</li>
<li><strong>y_lim_max</strong> – Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x_min, x_max, y_min, y_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_diff_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_diff_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to filter</li>
<li><strong>deg</strong> – (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_image_filter</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>im</strong> – Image to filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.in_ellipse">
<code class="descclassname">orb.utils.image.</code><code class="descname">in_ellipse</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.in_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is in the ellipse or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – X position of the point</li>
<li><strong>y</strong> – Y position of the point</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first last">Y position of the center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.interpolate_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">interpolate_map</code><span class="sig-paren">(</span><em>m</em>, <em>dimx</em>, <em>dimy</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<p>This function is robust to Nans.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The interpolation process is much longer if Nans are
present in the map.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Map</li>
<li><strong>dimx</strong> – X dimension of the result</li>
<li><strong>dimy</strong> – Y dimension of the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.low_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">low_pass_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to filter</li>
<li><strong>deg</strong> – Radius of the kernel. Must be &gt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.nanbin_image">
<code class="descclassname">orb.utils.image.</code><code class="descname">nanbin_image</code><span class="sig-paren">(</span><em>im</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image (or cube) binning robust to NaNs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image or cube to bin</li>
<li><strong>binning</strong> – Binning factor (must be an integer)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">adapted from <a class="reference external" href="https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy">https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy</a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.on_ellipse">
<code class="descclassname">orb.utils.image.</code><code class="descname">on_ellipse</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>x0</em>, <em>y0</em>, <em>rX</em>, <em>rY</em>, <em>theta</em>, <em>e=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.on_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is on the ellipse or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – X position of the point</li>
<li><strong>y</strong> – Y position of the point</li>
<li><strong>x0</strong> – X position of the center</li>
<li><strong>theta</strong> – Angle of the ellipse (in deg)</li>
<li><strong>rX</strong> – Radius of the X axis</li>
<li><strong>rY</strong> – Radius of the Y axis</li>
<li><strong>e</strong> – (Optional) Precision in pixels (default 0.5).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma y0:</th><td class="field-body"><p class="first last">Y position of the center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.polar_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">polar_map2d</code><span class="sig-paren">(</span><em>f</em>, <em>n</em>, <em>corner=False</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> – The function to map.</li>
<li><strong>n</strong> – Matrix size. Can be a couple of integers (nx, ny).</li>
<li><strong>corner</strong> – (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</li>
<li><strong>circle</strong> – (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.pp_create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">pp_create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Frames to combine.</li>
<li><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</li>
<li><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</li>
<li><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.shift_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">shift_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>dx</em>, <em>dy</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>order</em>, <em>fill_value=&lt;Mock id='140518076594640'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame wit the same dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Two dimensions array to be shifted</li>
<li><strong>dx</strong> – Shift value along the axis 0</li>
<li><strong>dy</strong> – Shift value along the axis 1</li>
<li><strong>x_max</strong><strong>, </strong><strong>y_min</strong><strong>, </strong><strong>y_max</strong> (<em>x_min</em><em>,</em>) – Boundaries of the region to be
shifted.</li>
<li><strong>order</strong> – interpolation order.</li>
<li><strong>(</strong><strong>Optional</strong><strong>)</strong> (<em>fill_value</em>) – Value of the extrapolated points
(default np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.simulate_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">simulate_calibration_laser_map</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>pixel_size</em>, <em>mirror_distance</em>, <em>theta_cx</em>, <em>theta_cy</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em>, <em>calib_laser_nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a calibration laser map from optical and mechanical
parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Number of pixels along X</li>
<li><strong>ny</strong> – Number of pixels along Y</li>
<li><strong>pixel_size</strong> – Size of a pixel in microns</li>
<li><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</li>
<li><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</li>
<li><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</li>
<li><strong>phi_x</strong> – Tilt of the mirror along X in degrees</li>
<li><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</li>
<li><strong>phi_r</strong> – Rotation angle of the camera in degrees</li>
<li><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.simulate_theta_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">simulate_theta_map</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>pixel_size</em>, <em>mirror_distance</em>, <em>theta_cx</em>, <em>theta_cy</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_theta_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate incident angle (theta) map from optical and mechanical
parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – Number of pixels along X</li>
<li><strong>ny</strong> – Number of pixels along Y</li>
<li><strong>pixel_size</strong> – Size of a pixel in microns</li>
<li><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</li>
<li><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</li>
<li><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</li>
<li><strong>phi_x</strong> – Tilt of the mirror along X in degrees</li>
<li><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</li>
<li><strong>phi_r</strong> – Rotation angle of the camera in degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.tilt_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">tilt_calibration_laser_map</code><span class="sig-paren">(</span><em>cmap</em>, <em>calib_laser_nm</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.tilt_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Tilt and rotate a calibration laser map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cmap</strong> – calibration laser map.</li>
<li><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm.</li>
<li><strong>phi_x</strong> – tilt angle along X axis (degrees).</li>
<li><strong>phi_y</strong> – tilt angle along Y axis (degrees).</li>
<li><strong>phi_r</strong> – Rotation angle (degrees).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.transform_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">transform_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>d</em>, <em>rc</em>, <em>zoom_factor</em>, <em>interp_order</em>, <em>mask=None</em>, <em>fill_value=&lt;Mock id='140518076594512'&gt;</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame to transform</li>
<li><strong>x_min</strong> – Lower x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>x_max</strong> – Upper x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>y_min</strong> – Lower y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>y_max</strong> – Upper y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><strong>d</strong> – Transformation coefficients [dx, dy, dr, da, db]</li>
<li><strong>rc</strong> – Rotation center of the frame [rc_x, rc_y]</li>
<li><strong>zoom_factor</strong> – Zoom on the image. Can be a couple (zx, zy).</li>
<li><strong>interp_order</strong> – Interpolation order</li>
<li><strong>mask</strong> – (Optional) If a mask frame is passed it is
transformed also (default None).</li>
<li><strong>fill_value</strong> – (Optional) Fill value for extrapolated points
(default np.nan).</li>
<li><strong>sip_A</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the output image (default None).</li>
<li><strong>sip_B</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the input image (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.unwrap_phase_map0">
<code class="descclassname">orb.utils.image.</code><code class="descname">unwrap_phase_map0</code><span class="sig-paren">(</span><em>phase_map</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.unwrap_phase_map0" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase is defined modulo pi/2. The Unwrapping is a
reconstruction of the phase so that the distance between two
neighbour pixels is always less than pi/4. Then the real
phase pattern can be recovered and fitted easily.</p>
<p>The idea is the same as with np.unwrap() but in 2D, on a
possibly very noisy map, where a naive 2d unwrapping cannot
be done.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>phase_map</strong> – Order 0 phase map.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.io">
<span id="orb-utils-io-module"></span><h2>orb.utils.io module<a class="headerlink" href="#module-orb.utils.io" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.io.bin_image">
<code class="descclassname">orb.utils.io.</code><code class="descname">bin_image</code><span class="sig-paren">(</span><em>a</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.bin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean binned image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> – 2d array to bin.</li>
<li><strong>binning</strong> – binning (must be an integer &gt;= 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only the complete sets of rows or columns are binned
so that depending on the bin size and the image size the
last columns or rows can be ignored. This ensures that the
binning surface is the same for every pixel in the binned
array.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_hdu_data_index">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_hdu_data_index</code><span class="sig-paren">(</span><em>hdul</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_hdu_data_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first header data unit (HDU) containing data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdul</strong> – A pyfits.HDU instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_sitelle_slice">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_sitelle_slice</code><span class="sig-paren">(</span><em>slice_str</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_sitelle_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip a string containing SITELLE like slice coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>slice_str</strong> – Slice string.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>no_error=False</em>, <em>nan_filter=False</em>, <em>return_header=False</em>, <em>return_hdu_only=False</em>, <em>return_mask=False</em>, <em>silent=False</em>, <em>delete_after=False</em>, <em>data_index=0</em>, <em>image_mode='classic'</em>, <em>chip_index=None</em>, <em>binning=None</em>, <em>fix_header=True</em>, <em>dtype=&lt;type 'float'&gt;</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a FITS data file and returns its data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</li>
<li><strong>no_error</strong> – (Optional) If True this function will only
display a warning message if the file does not exist (so it
does not raise an exception) (default False)</li>
<li><strong>nan_filter</strong> – (Optional) If True replace NaN by zeros
(default False)</li>
<li><strong>return_header</strong> – (Optional) If True return a tuple (data,
header) (default False).</li>
<li><strong>return_hdu_only</strong> – (Optional) If True return FITS header
data unit only. No data will be returned (default False).</li>
<li><strong>return_mask</strong> – (Optional) If True return only the mask
corresponding to the data file (default False).</li>
<li><strong>silent</strong> – (Optional) If True no message is displayed
except if an error is raised (default False).</li>
<li><strong>delete_after</strong> – (Optional) If True delete file after
reading (default False).</li>
<li><strong>data_index</strong> – (Optional) Index of data in the header data
unit (Default 0).</li>
<li><strong>image_mode</strong> – (Optional) Can be ‘sitelle’, ‘spiomm’ or
‘classic’. In ‘sitelle’ mode, the parameter
chip_index must also be set to 0 or 1. In this mode only
one of both SITELLE quadrants is returned. In ‘classic’ mode
the whole frame is returned (default ‘classic’).</li>
<li><strong>chip_index</strong> – (Optional) Index of the chip of the
SITELLE image. Used only if image_mode is set to ‘sitelle’
In this case, must be 1 or 2. Else must be None (default
None).</li>
<li><strong>binning</strong> – (Optional) If not None, returned data is
binned by this amount (must be an integer &gt;= 1)</li>
<li><strong>fix_header</strong> – (Optional) If True, fits header is
fixed to avoid errors due to header inconsistencies
(e.g. WCS errors) (default True).</li>
<li><strong>dtype</strong> – (Optional) Data is converted to
the given dtype (e.g. np.float32, default float).</li>
<li><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module. And
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_sitelle_chip">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_sitelle_chip</code><span class="sig-paren">(</span><em>hdu</em>, <em>chip_index</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_sitelle_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return chip data of a SITELLE FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdu</strong> – pyfits.HDU Instance of the SITELLE image</li>
<li><strong>chip_index</strong> – Index of the chip to read. Must be 1 or 2.</li>
<li><strong>substract_bias</strong> – If True bias is automatically
substracted by using the overscan area (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_spiomm_data">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_spiomm_data</code><span class="sig-paren">(</span><em>hdu</em>, <em>image_path</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_spiomm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data of an SpIOMM FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdu</strong> – pyfits.HDU Instance of the SpIOMM image</li>
<li><strong>image_path</strong> – Image path</li>
<li><strong>substract_bias</strong> – If True bias is automatically
substracted by using the associated bias frame as an
overscan frame. Mean bias level is thus computed along the y
axis of the bias frame (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.write_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">write_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>fits_data</em>, <em>fits_header=None</em>, <em>silent=False</em>, <em>overwrite=False</em>, <em>mask=None</em>, <em>replace=False</em>, <em>record_stats=False</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in FITS format. If the file doesn’t exist create
it with its directories.</p>
<p>If the file already exists add a number to its name before the
extension (unless ‘overwrite’ option is set to True).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</li>
<li><strong>fits_data</strong> – Data to be written in the file.</li>
<li><strong>fits_header</strong> – (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), …]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed.</li>
<li><strong>silent</strong> – (Optional) If True turn this function won’t
display any message (default False)</li>
<li><strong>overwrite</strong> – (Optional) If True overwrite the output file
if it exists (default False).</li>
<li><strong>mask</strong> – (Optional) It not None must be an array with the
same size as the given data but filled with ones and
zeros. Bad values (NaN or Inf) are converted to 1 and the
array is converted to 8 bit unsigned integers (uint8). This
array will be written to the disk with the same path
terminated by ‘_mask’. The header of the mask FITS file will
be the same as the original data (default None).</li>
<li><strong>replace</strong> – (Optional) If True and if the file already
exist, new data replace old data in the existing file. NaN
values do not replace old values. Other values replace old
values. New array MUST have the same size as the existing
array. Note that if replace is True, overwrite is
automatically set to True.</li>
<li><strong>record_stats</strong> – (Optional) If True, record mean and
median of data. Useful if they often have to be computed
(default False).</li>
<li><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">float64 data is converted to float32 data to avoid
too big files with unnecessary precision</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module and
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.log">
<span id="orb-utils-log-module"></span><h2>orb.utils.log module<a class="headerlink" href="#module-orb.utils.log" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.log.setup_socket_logging">
<code class="descclassname">orb.utils.log.</code><code class="descname">setup_socket_logging</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.log.setup_socket_logging" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-orb.utils.misc">
<span id="orb-utils-misc-module"></span><h2>orb.utils.misc module<a class="headerlink" href="#module-orb.utils.misc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.misc.aggregate_pixels">
<code class="descclassname">orb.utils.misc.</code><code class="descname">aggregate_pixels</code><span class="sig-paren">(</span><em>pixel_list</em>, <em>radius=1.42</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.aggregate_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate neighbouring pixels into a set of sources. Two
neighbours are found if there distance is smaller than a given
radius (in pixels).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pixel_list</strong> – A list of pixel position as returned by a
function like numpy.nonzero.</li>
<li><strong>radius</strong> – (Optional) Max separation between two pixels of the
same source (default 1.42).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of pixel list. Each item of the list corresponds
to a source and each source is itself a list of pixel positions
(x,y).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.compute_obs_params">
<code class="descclassname">orb.utils.misc.</code><code class="descname">compute_obs_params</code><span class="sig-paren">(</span><em>nm_min_filter</em>, <em>nm_max_filter</em>, <em>theta_min=5.01</em>, <em>theta_max=11.28</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nm_min_filter</strong> – Min wavelength of the filter in nm.</li>
<li><strong>nm_max_filter</strong> – Max wavelength of the filter in nm.</li>
<li><strong>theta_min</strong> – (Optional) Min angle of the detector (default
5.01).</li>
<li><strong>theta_max</strong> – (Optional) Max angle of the detector (default
11.28).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (order, step size, max wavelength)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.correct_bad_frames_vector">
<code class="descclassname">orb.utils.misc.</code><code class="descname">correct_bad_frames_vector</code><span class="sig-paren">(</span><em>bad_frames_vector</em>, <em>dimz</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bad_frames_vector</strong> – The vector of indexes to correct</li>
<li><strong>dimz</strong> – Dimension of the cube along the 3rd axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_axis_from_hdr">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_axis_from_hdr</code><span class="sig-paren">(</span><em>hdr</em>, <em>axis_index=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_axis_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return axis from a classic FITS header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> – FITS header</li>
<li><strong>axis_index</strong> – (Optional) Index of the axis to retrieve
(default 1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_mask_from_ds9_region_file">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_mask_from_ds9_region_file</code><span class="sig-paren">(</span><em>reg_path</em>, <em>x_range</em>, <em>y_range</em>, <em>integrate=True</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mask from a ds9 region file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reg_path</strong> – Path to a ds9 region file</li>
<li><strong>x_range</strong> – Range of x image coordinates
considered as valid. Pixels outside this range are
rejected..</li>
<li><strong>y_range</strong> – Range of y image coordinates
considered as valid. Pixels outside this range are
rejected.</li>
<li><strong>integrate</strong> – (Optional) If True, all pixels are integrated
into one mask, else a list of region masks is returned (default
True)</li>
<li><strong>header</strong> – (Optional) Header containing the WCS transformation
if the region file is in celestial coordinates (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be celestial or image coordinates
(x,y). if coordinates are celestial a header must be passed to
the function.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.load_dill">
<code class="descclassname">orb.utils.misc.</code><code class="descname">load_dill</code><span class="sig-paren">(</span><em>dill_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.load_dill" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a dill object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dill_path</strong> – Path to the input file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.restore_error_settings">
<code class="descclassname">orb.utils.misc.</code><code class="descname">restore_error_settings</code><span class="sig-paren">(</span><em>old_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.save_dill">
<code class="descclassname">orb.utils.misc.</code><code class="descname">save_dill</code><span class="sig-paren">(</span><em>dill_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.save_dill" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a dill object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dill_path</strong> – Path to the output file</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.parallel">
<span id="orb-utils-parallel-module"></span><h2>orb.utils.parallel module<a class="headerlink" href="#module-orb.utils.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.parallel.close_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">close_pp_server</code><span class="sig-paren">(</span><em>js</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.close_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy the parallel python job server to avoid too much
opened files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>js</strong> – job server.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.get_stats_str">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">get_stats_str</code><span class="sig-paren">(</span><em>js</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.get_stats_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return job server statistics as a string</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.init_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">init_pp_server</code><span class="sig-paren">(</span><em>ncpus=0</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.init_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a server for parallel processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ncpus</strong> – (Optional) Number of cpus to use. 0 means use all
available cpus (default 0)</li>
<li><strong>silent</strong> – (Optional) If silent no message is printed
(Default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.timed_process">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">timed_process</code><span class="sig-paren">(</span><em>func</em>, <em>timeout</em>, <em>args=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.timed_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a timed process which terminates after timeout seconds if it
does not return before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> – Timed func which will be terminated after timeout
seconds. must be func(<a href="#id3"><span class="problematic" id="id4">*</span></a>args, returned_dict). The
results of the function must be put in returned_dict.</li>
<li><strong>timeout</strong> – Timeout in s.</li>
<li><strong>args</strong> – arguments of the function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">returned_dict</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">from <a class="reference external" href="https://stackoverflow.com/questions/492519/timeout-on-a-function-call">https://stackoverflow.com/questions/492519/timeout-on-a-function-call</a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.photometry">
<span id="orb-utils-photometry-module"></span><h2>orb.utils.photometry module<a class="headerlink" href="#module-orb.utils.photometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.photometry.ABmag2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2flambda</code><span class="sig-paren">(</span><em>ABmag</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ABmag</strong> – A magnitude in the AB magnitude system</li>
<li><strong>lam</strong> – Wavelength in angstrom</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.ABmag2fnu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2fnu</code><span class="sig-paren">(</span><em>ABmag</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ABmag</strong> – A magnitude in the AB magnitude system</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_equivalent_bandwidth">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_equivalent_bandwidth</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_equivalent_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent bandwidth of a given filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Filter transmission axis in nm.</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_flux_calibration_vector">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_flux_calibration_vector</code><span class="sig-paren">(</span><em>re_spectrum</em>, <em>th_spectrum</em>, <em>std_step</em>, <em>std_order</em>, <em>std_exp_time</em>, <em>std_corr</em>, <em>filter_function</em>, <em>filter_min_pix</em>, <em>filter_max_pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_flux_calibration_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the flux calibration vector from an observed spectrum
and the standard spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>re_spectrum</strong> – Observed spectrum in wavenumber.</li>
<li><strong>th_spectrum</strong> – standard spectrum (in erg/cm2/s/A) in wavenumber.</li>
<li><strong>std_step</strong> – Standard step size (in nm)</li>
<li><strong>std_order</strong> – Standard folding order</li>
<li><strong>std_exp_time</strong> – Standard Exposition time</li>
<li><strong>std_corr</strong> – Standard Correction coeff.</li>
<li><strong>filter_function</strong> – Filter function</li>
<li><strong>filter_min_pix</strong> – Filter min position in pixels</li>
<li><strong>filter_max_pix</strong> – Filter max position in pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean energy of the photons passing thourgh a given
filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Filter transmission axis in nm.</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_star_flux">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_star_flux</code><span class="sig-paren">(</span><em>star_spectrum</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_star_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean star flux given a spectrum and the filter. Both
files must be given along the same wavelength/wavenumber axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_spectrum</strong> – Spectrum of the star</li>
<li><strong>filter_transmission</strong> – Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_optimal_texp">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_optimal_texp</code><span class="sig-paren">(</span><em>star_flux</em>, <em>seeing</em>, <em>plate_scale</em>, <em>saturation=30000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_optimal_texp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the optimal exposure time given the total flux of the
star in ADU/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_flux</strong> – Total star flux in ADU/s</li>
<li><strong>seeing</strong> – Star FWHM in arcsec</li>
<li><strong>plate_scale</strong> – Size of 1 pixel in arcsec.</li>
<li><strong>saturation</strong> – (Optional) Saturation value (default 30000).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the photon energy computed for all the wavelength along
a given wavelength axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm_axis</strong> – Wavelength axis in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_star_central_pixel_value">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_star_central_pixel_value</code><span class="sig-paren">(</span><em>seeing</em>, <em>plate_scale</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_central_pixel_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative value of the pixel containing the greatest
proportion of the flux (central pixel) of Gaussian star.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>seeing</strong> – Star FWHM in arcsec</li>
<li><strong>plate_scale</strong> – Size of the pixels in arcsec.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_star_flux_in_frame">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_star_flux_in_frame</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>star_flux</em>, <em>filter_trans</em>, <em>optics_trans</em>, <em>atm_trans</em>, <em>mirror_trans</em>, <em>qe</em>, <em>mirror_surface</em>, <em>ccd_gain</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_flux_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the estimation of the flux of a star in counts/s in one image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Wavelentgh axis in nm</li>
<li><strong>star_flux</strong> – Star flux curve in ergs/cm2/s/A</li>
<li><strong>filter_trans</strong> – Transmission curve of the filter</li>
<li><strong>optics_trans</strong> – Transmission of the optics</li>
<li><strong>atm_trans</strong> – Transmission of the atmosphere</li>
<li><strong>qe</strong> – Quantum Efficiency curve of the detector</li>
<li><strong>mirror_surface</strong> – Surface of the primary mirror in cm2</li>
<li><strong>ccd_gain</strong> – Gain of the detector.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.convert_cm1_flux2fluxdensity">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">convert_cm1_flux2fluxdensity</code><span class="sig-paren">(</span><em>a</em>, <em>cm1_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.convert_cm1_flux2fluxdensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a spectrum in X/s to X/s/A (X may be ADU or erg/cm^2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – spectrum</li>
<li><strong>cm1_axis</strong> – Axis of the spectrum in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fit_std_spectrum">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fit_std_spectrum</code><span class="sig-paren">(</span><em>real_spectrum</em>, <em>std_spectrum</em>, <em>polydeg=2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fit_std_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a real spectrum multiplied by a polynomial over a standard
spectrum.</p>
<p>Return the polynomial which can be used directly as a calibration
curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>real_spectrum</strong> – Observed spectrum</li>
<li><strong>std_spectrum</strong> – Standard spectrum</li>
<li><strong>polydeg</strong> – Degree of the polynomial</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.flambda2ABmag">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">flambda2ABmag</code><span class="sig-paren">(</span><em>flambda</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.flambda2ABmag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return AB magnitude from flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>flambda</strong> – Flux in erg/cm2/s/A. Can be an array.</li>
<li><strong>lambda</strong> – Wavelength in A of the Flux. If flambda is an array
lambda must have the same shape.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fnu2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fnu2flambda</code><span class="sig-paren">(</span><em>fnu</em>, <em>nu</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fnu</strong> – Flux in erg/cm2/s/Hz</li>
<li><strong>nu</strong> – frequency in Hz</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_atmospheric_extinction">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_atmospheric_extinction</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_atmospheric_extinction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atmospheric extinction curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>step_nb</strong> – Number of step along the nm axis.</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_atmospheric_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_atmospheric_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>airmass=1</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_atmospheric_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atmospheric transmission curve at a given airmass
in the range defined by the observation parameters along a
reference nm axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>step_nb</strong> – Number of step along the nm axis.</li>
<li><strong>airmass</strong> – (Optional) Airmass (default 1)</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_mirror_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_mirror_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_mirror_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mirror transmission curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>step_nb</strong> – Number of step along the nm axis.</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_optics_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_optics_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_optics_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the optics transmission curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>step_nb</strong> – Number of step along the nm axis.</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_quantum_efficiency">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_quantum_efficiency</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_quantum_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the quantum efficiency curve in the range defined by the
observation parameters along a reference nm axis (on the
interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_path</strong> – Path to the file</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>step_nb</strong> – Number of step along the nm axis.</li>
<li><strong>corr</strong> – (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.lambda2nu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">lambda2nu</code><span class="sig-paren">(</span><em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lam</strong> – Wavelength in angstrom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_atmospheric_extinction_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_atmospheric_extinction_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_atmospheric_extinction_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read atmospheric extinction file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> – Path to the atmospheric extinction file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], atmospheric extinction in
[mag/airmass])</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_mirror_transmission_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_mirror_transmission_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_mirror_transmission_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read mirror transmission file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> – Path to the file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], Mirror transmission (from 0 to 1))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_optics_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_optics_file</code><span class="sig-paren">(</span><em>optics_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_optics_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing the optics transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>optics_file_path</strong> – Path to the optics file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(wavelength, transmission coefficients)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The optics file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.</p>
<blockquote class="last">
<div>## ORBS optics file
# Author: Thomas Martin &lt;<a class="reference external" href="mailto:thomas&#46;martin&#46;1&#37;&#52;&#48;ulaval&#46;ca">thomas<span>&#46;</span>martin<span>&#46;</span>1<span>&#64;</span>ulaval<span>&#46;</span>ca</a>&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_quantum_efficiency_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_quantum_efficiency_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_quantum_efficiency_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read quantum efficiency file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> – Path to the file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], quantum efficiency (from 0 to 1))</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.sim">
<span id="orb-utils-sim-module"></span><h2>orb.utils.sim module<a class="headerlink" href="#module-orb.utils.sim" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.sim.fft">
<code class="descclassname">orb.utils.sim.</code><code class="descname">fft</code><span class="sig-paren">(</span><em>interf</em>, <em>zp_coeff=10</em>, <em>apod=None</em>, <em>phase=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic Fourier Transform with zero-padding.</p>
<p>Useful to compute a quick assumption-less FFT.</p>
<p>ZPD is assumed to be on the first sample of the interferogram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – interferogram</li>
<li><strong>zp_coeff</strong> – Zero-padding coefficient</li>
<li><strong>apod</strong> – Apodization function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">axis, complex interferogram FFT</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.sim.line_interf">
<code class="descclassname">orb.utils.sim.</code><code class="descname">line_interf</code><span class="sig-paren">(</span><em>sigma</em>, <em>step_nb</em>, <em>phi=0</em>, <em>symm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.line_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a simple line interferogram (a cosine)</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> – line frequency (must be &lt; step_nb/2)</li>
<li><strong>step_nb</strong> – Length of the interferogram</li>
<li><strong>phi</strong> – (Optional) Phase of the line (in radians) (default 0).</li>
<li><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.sim.step_interf">
<code class="descclassname">orb.utils.sim.</code><code class="descname">step_interf</code><span class="sig-paren">(</span><em>sigma_min</em>, <em>sigma_max</em>, <em>step_nb</em>, <em>symm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.step_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a step interferogram</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma_ax</strong> – max frequency of the step (must be &lt; step_nb/2)</li>
<li><strong>step_nb</strong> – Length of the interferogram</li>
<li><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">results are much better with a symmetric interferogram
but ZPD is not on the first sample and the spectrum must thus be
phase corrected.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.spectrum">
<span id="orb-utils-spectrum-module"></span><h2>orb.utils.spectrum module<a class="headerlink" href="#module-orb.utils.spectrum" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.spectrum.cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12nm</code><span class="sig-paren">(</span><em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a wavelength in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cm1</strong> – wavenumber in cm-1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.cm12pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12pix</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1_axis</strong> – Axis in cm-1</li>
<li><strong>cm1</strong> – Wavenumber in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>apod_coeff=1.0</em>, <em>corr=1.0</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM (in nm or in cm-1) of a line given the
observation parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps from the zpd to the longest side
of the interferogram.</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>apod_coeff</strong> – (Optional) Apodization coefficient. 1. stands
for no apodization and gives the FWHM of the central lobe of the
sinc (default 1.)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm_pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm_pix</code><span class="sig-paren">(</span><em>oversampling_ratio=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM of an unapodized sinc line in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Oversampling_ratio:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Ratio of the real number of steps of the
spectrum vs step_nb (must be &gt; 1.) For a two sided interferogram
the oversampling ratio is 2.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_mean_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_mean_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_mean_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean shift at the central wavelength of the band
defined by step and order parameters given its velocity in nm or
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>velocity</strong> – Line velocity in km.s-1</li>
<li><strong>step_nb</strong> – Number of steps</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_radial_velocity">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_radial_velocity</code><span class="sig-paren">(</span><em>line</em>, <em>rest_line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_radial_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radial velocity in km.s-1</p>
<p>V [km.s-1] = c [km.s-1]* (Lambda^2 / Lambda_0^2 - 1) / (Lambda^2 / Lambda_0^2 + 1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>line</strong> – Emission line wavelength/wavenumber (can be a numpy
array)</li>
<li><strong>rest_line</strong> – Rest-frame wavelength/wavenumber (can be a numpy
array but must have the same size as line)</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_resolution">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_resolution</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>corr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the theoretical resolution of a given scan</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps of the longest side of the
interferogram.</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – Correction coefficient for the incident angle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_step_nb">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_step_nb</code><span class="sig-paren">(</span><em>resolution</em>, <em>step</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_step_nb" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of steps on the longest side of the
interferogram given the resolution and the observation
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>resolution</strong> – Resolution</li>
<li><strong>step</strong> – Step size (in nm)</li>
<li><strong>order</strong> – Folding order</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.corr2theta">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">corr2theta</code><span class="sig-paren">(</span><em>corr</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.corr2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the correction coefficient to an incident angle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>corr</strong> – Correction coefficient</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_cm1_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_cm1_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (cannot be 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis_ireg">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis_ireg</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (must be &gt; 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fast_pix2w">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fast_pix2w</code><span class="sig-paren">(</span><em>pix</em>, <em>axis_min</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_pix2w" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of pixel to wavelength/wavenumber</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pix</strong> – position along axis in pixels</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fast_w2pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fast_w2pix</code><span class="sig-paren">(</span><em>w</em>, <em>axis_min</em>, <em>axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_w2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of wavelength/wavenumber to pixel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> – wavelength/wavenumber</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_cm12nm</code><span class="sig-paren">(</span><em>fwhm_cm1</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in cm-1 to a FWHM in nm.</p>
<p>The central wavelength in cm-1 of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm_cm1</strong> – FWHM in cm-1</li>
<li><strong>cm1</strong> – Wavelength in cm-1 where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_nm2cm1</code><span class="sig-paren">(</span><em>fwhm_nm</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in nm to a FWHM in cm-1.</p>
<p>The central wavelength in nm of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm_nm</strong> – FWHM in nm</li>
<li><strong>nm</strong> – Wavelength in nm where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Array giving the positions where the gaussian is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM, <span class="math">\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Array giving the positions where the gaussian is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM, <span class="math">\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D Gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.guess_snr">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">guess_snr</code><span class="sig-paren">(</span><em>calib_spectrum</em>, <em>flambda</em>, <em>exp_time</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.guess_snr" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess calibrated spectrum snr</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calib_spectrum</strong> – Calibrated spectrum</li>
<li><strong>flambda</strong> – Calibration FLAMBDA</li>
<li><strong>exp_time</strong> – Exposure time by step</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.line_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">line_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift given its velocity in nm or in cm-1.</p>
<p>beta = v / c</p>
<p>gamma = sqrt((1 + beta) / (1 - beta))</p>
<p>lambda - lambda_0 = lambda_0  * (gamma - 1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>velocity</strong> – Line velocity in km.s-1</li>
<li><strong>line</strong> – Wavelength/wavenumber of the line. Must be in cm-1 if
wavenumber is True, must be in nm otherwise.</li>
<li><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.lorentzian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">lorentzian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.lorentzian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D lorentzian
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2cm1</code><span class="sig-paren">(</span><em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a wavenumber in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm</strong> – wavelength in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2pix</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
fast_w2pix is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Axis in nm</li>
<li><strong>nm</strong> – Wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.phase_shift_cm1_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">phase_shift_cm1_axis</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>nm_laser_obs</em>, <em>nm_laser</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.phase_shift_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute phase shift on a given cm1 axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_nb</strong> – Number of steps</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>nm_laser_obs</strong> – Observed calibration laser wavelength (in nm)</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength (in nm)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2cm1</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cm1_axis</strong> – Axis in cm-1</li>
<li><strong>pix</strong> – Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2nm</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
fast_pix2w is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> – Axis in nm</li>
<li><strong>pix</strong> – Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sinc (understood as the Fourier
Transform of a boxcar function from 0 to MPD).</p>
<p>This is the real sinc function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d_phased">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d_phased</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc function when that can be used to
fit a spectrum with a non perfect correction of the order 0 of the
phase.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>alpha</strong> – Mixing coefficient (in radians).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc21d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc21d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc21d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc2.
THIS IS BOGUS WITH CURRENT DEFINITION OF SINC2 MODEL
:param a: Amplitude
:param fwhm: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc convoluted with a gaussian of parameter sigma.</p>
<p>If sigma == 0 returns a pure sinc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – 1D array of float64 giving the positions where the</td>
</tr>
</tbody>
</table>
<p>sinc is evaluated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_complex">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_complex</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (dawson definition).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_complex_erf">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_complex_erf</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (erf formulation).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_flux">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_flux</code><span class="sig-paren">(</span><em>a</em>, <em>fwhm</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc convoluted with a Gaussian of
parameter sigma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Amplitude</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian</li>
<li><strong>no_err</strong> – (Optional) No error is returned (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sincgauss1d_phased">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sincgauss1d_phased</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em>, <em>sigma</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc*gauss function when that can be
used to fit a spectrum with a non perfect correction of the order
0 of the phase.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>fwhm</strong> – FWHM of the sinc</li>
<li><strong>sigma</strong> – Sigma of the gaussian.</li>
<li><strong>alpha</strong> – Mixing coefficient (in radians).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.thermal_broadening_kms">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">thermal_broadening_kms</code><span class="sig-paren">(</span><em>wl</em>, <em>aw</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.thermal_broadening_kms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the line due to thermal broadening in km/s.</p>
<p>Equation can be refered to Harwit (Astrophysical concepts) but his
definition gives the HWHM (Half-Width at Half-Maximum).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wl</strong> – Wavelength of the line (in nm)</li>
<li><strong>aw</strong> – Atomic weight of the emitting atom</li>
<li><strong>T</strong> – Temperature in K</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.theta2corr">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">theta2corr</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.theta2corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the incident angle to a correction coefficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>theta</strong> – Incident angle in degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.stats">
<span id="orb-utils-stats-module"></span><h2>orb.utils.stats module<a class="headerlink" href="#module-orb.utils.stats" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.stats.robust_mean">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_mean</code><span class="sig-paren">(</span><em>a</em>, <em>weights=None</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>weights</strong> – Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_median">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_median</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_std">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_std</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_sum">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_sum</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – A distribution of values</li>
<li><strong>warn</strong> – If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.sigmacut">
<code class="descclassname">orb.utils.stats.</code><code class="descname">sigmacut</code><span class="sig-paren">(</span><em>x</em>, <em>sigma=3.0</em>, <em>min_values=3</em>, <em>central_value=None</em>, <em>warn=False</em>, <em>return_index_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – The distribution to cut</li>
<li><strong>sigma</strong> – (Optional) Number of sigma above which values are
considered as deviant (default 3.)</li>
<li><strong>min_values</strong> – (Optional) Minimum number of values to return
(default 3)</li>
<li><strong>central_value</strong> – (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</li>
<li><strong>warn</strong> – (Optional) If False no warning message is printed
(default False).</li>
<li><strong>return_index_list</strong> – (Optional) If True the list of the non
rejected values is returned also (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.validate">
<span id="orb-utils-validate-module"></span><h2>orb.utils.validate module<a class="headerlink" href="#module-orb.utils.validate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.validate.has_dtype">
<code class="descclassname">orb.utils.validate.</code><code class="descname">has_dtype</code><span class="sig-paren">(</span><em>obj</em>, <em>dtype</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray of the correct type
:param obj: object to validate
:param dtype: array dtype
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.has_len">
<code class="descclassname">orb.utils.validate.</code><code class="descname">has_len</code><span class="sig-paren">(</span><em>obj</em>, <em>length</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is 1d and if its length is correct
:param obj: Object to check
:param raise_exception: If True raise an exception else raise a warning.
:param length: length of the object</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.have_same_shape">
<code class="descclassname">orb.utils.validate.</code><code class="descname">have_same_shape</code><span class="sig-paren">(</span><em>objs</em>, <em>raise_exception=True</em>, <em>object_name='arrays'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.have_same_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all numpy.ndarrays have the same shape
:param obj: list of objects to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.index">
<code class="descclassname">orb.utils.validate.</code><code class="descname">index</code><span class="sig-paren">(</span><em>a</em>, <em>a_min</em>, <em>a_max</em>, <em>clip=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a valid index (clipped between a_min and a_max - 1) or raise
an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – index. Can be a list or an array of indexes.</li>
<li><strong>a_min</strong> – Min index.</li>
<li><strong>a_max</strong> – Max index (max possible index will be considered as
a_max -1)</li>
<li><strong>clip</strong> – (Optional) If True return an index inside the
boundaries, else: raise an exception (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_1darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_1darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_1darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 1d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_2darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_2darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_2darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 2d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_3darray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_3darray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_3darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 3d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_iterable">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_iterable</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>check if object is a tuple or a list or a 1darray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> – Object to check</li>
<li><strong>raise_exception</strong> – If True raise an exception else raise a warning.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_ndarray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_ndarray</code><span class="sig-paren">(</span><em>obj</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.validate.is_xdarray">
<code class="descclassname">orb.utils.validate.</code><code class="descname">is_xdarray</code><span class="sig-paren">(</span><em>obj</em>, <em>ndim</em>, <em>raise_exception=True</em>, <em>object_name='object'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_xdarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray with the correct number of
dimensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> – object to validate</li>
<li><strong>ndim</strong> – number of dimensions</li>
<li><strong>raise_exception</strong> – If True raise an exception else raise a warning.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.vector">
<span id="orb-utils-vector-module"></span><h2>orb.utils.vector module<a class="headerlink" href="#module-orb.utils.vector" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.vector.correct_vector">
<code class="descclassname">orb.utils.vector.</code><code class="descname">correct_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>bad_value=&lt;Mock id='140518077013072'&gt;</em>, <em>deg=3</em>, <em>polyfit=False</em>, <em>smoothing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vector</strong> – The vector to be corrected.</li>
<li><strong>bad_value</strong> – (Optional) Bad value to correct (default np.nan)</li>
<li><strong>deg</strong> – (Optional) Spline degree or polyfit degree (default 3)</li>
<li><strong>polyfit</strong> – (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.fft_filter">
<code class="descclassname">orb.utils.vector.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>a</em>, <em>cutoff_coeff</em>, <em>width_coeff=0.2</em>, <em>filter_type='high_pass'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Vector to filter</li>
<li><strong>cutoff_coeff</strong> – Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</li>
<li><strong>width_coeff</strong> – (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</li>
<li><strong>filter_type</strong> – (Optional) Type of filter to use. Can be
‘high_pass’ or ‘low_pass’.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_axis">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_axis</code><span class="sig-paren">(</span><em>a</em>, <em>new_axis</em>, <em>deg</em>, <em>old_axis=None</em>, <em>fill_value=&lt;Mock id='140518077013200'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – vector to interpolate</li>
<li><strong>new_axis</strong> – Interpolation axis</li>
<li><strong>deg</strong> – Interpolation degree</li>
<li><strong>old_axis</strong> – (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</li>
<li><strong>fill_value</strong> – (Optional) extrapolated points are filled with
this value (default np.nan)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_size">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_size</code><span class="sig-paren">(</span><em>a</em>, <em>size</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – vector to interpolate</li>
<li><strong>size</strong> – New size of the vector</li>
<li><strong>deg</strong> – Interpolation degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.polyfit1d">
<code class="descclassname">orb.utils.vector.</code><code class="descname">polyfit1d</code><span class="sig-paren">(</span><em>a</em>, <em>deg</em>, <em>w=None</em>, <em>return_coeffs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – Vector to fit</li>
<li><strong>deg</strong> – Fit degree</li>
<li><strong>return_coeffs</strong> – (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</li>
<li><strong>w</strong> – (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.smooth">
<code class="descclassname">orb.utils.vector.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>a</em>, <em>deg=2</em>, <em>kind='gaussian'</em>, <em>keep_sides=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – Vector to smooth</li>
<li><strong>deg</strong> – (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</li>
<li><strong>kind</strong> – Kind of smoothing function. ‘median’ or ‘mean’ are
self-explanatory. ‘gaussian’ uses a gaussian function for a
weighted average. ‘gaussian_conv’ and ‘cos_conv’ make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default ‘gaussian’).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params keep_sides:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last">If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.web">
<span id="orb-utils-web-module"></span><h2>orb.utils.web module<a class="headerlink" href="#module-orb.utils.web" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.web.query_sesame">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_sesame</code><span class="sig-paren">(</span><em>object_name</em>, <em>verbose=True</em>, <em>degree=False</em>, <em>pm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_sesame" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the SESAME Database to get RA/DEC given the name of an
object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>object_name</strong> – Name of the object</li>
<li><strong>verbose</strong> – (Optional) If True print messages (default True)</li>
<li><strong>degree</strong> – (Optional) If True return RA DEC in degrees
(default False)</li>
<li><strong>pm</strong> – (Optional) If True proper motion is also returned
(default False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[RA, DEC]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.web.query_vizier">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_vizier</code><span class="sig-paren">(</span><em>radius</em>, <em>target_ra</em>, <em>target_dec</em>, <em>catalog='gaia'</em>, <em>max_stars=100</em>, <em>return_all_columns=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<p>Note that the idea of this method has been picked from an IDL
function: QUERYVIZIER
(<a class="reference external" href="http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro">http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radius</strong> – Radius around the target in arc-minutes.</li>
<li><strong>target_ra</strong> – Target RA in degrees</li>
<li><strong>target_dec</strong> – Target DEC in degrees</li>
<li><strong>max_stars</strong> – (Optional) Maximum number of rows to retrieve
(default 100)</li>
<li><strong>catalog</strong> – (Optional) can be ‘usno’ - Version B1 of the US
Naval Observatory catalog (2003), ‘gaia’ - GAIA DR1, or ‘2mass’
- 2MASS (default Gaia)</li>
<li><strong>return_all_columns</strong> – (Optional) If True, return all
columns. Else only ra, dec and Mag are returned (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="code.html" class="btn btn-neutral float-left" title="Code documentation: core modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Thomas Martin

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>